Java Language binding for IoTivity-Lite using SWIG
-------------------------------------------------

Introduction
=================================================
A tool called SWIG is used to generate Java language bindings for IoTivity-Lite.  SWIG is an
interface compiler that connects programs written in C and C++ with other languages such as Java.

SWIG is not a stubs generator.  It produces code that can be compiled and used.  The output is
generated by a tool.  For this reason there is little or no encapsulation of the code to make it
appear more like what most Java developers would expect.  The output with very few
exceptions are just a collection of classes filled with static methods.  This has both the
advantage and disadvantage that the way the code is used in Java is similar to the way it is used
in C.  This means the code does not resemble what a typical Java programmer expects but it is easy
for someone familiar with the C code to follow the flow of the code.

The Java output is still in early development and is expected to change.  Since the Java output
is just a thin layer on top of IoTivity-Lite C code any programs developed using Java are
expected to be as stable as the underlying C code.

Getting Started
=================================================
To use this code you will need the following:
  - git version control system
  - A local copy of IoTivity-Lite
  - SWIG installed on your local system
  - Java Development kit.
  - C build tool for your desired system

### Get git
It can be installed on Ubuntu Linux using the following command.

    sudo apt-get install git

Git can be obtained for Windows [here](https://git-scm.com/download/win).

### Get IoTivity-Lite
Checkout IoTivity-Lite git project run the following command to get a anonymous copy of
iotivity-lite.  Checkout the SWIG branch.

    git clone https://gerrit.iotivity.org/gerrit/iotivity-lite
    git checkout -t origin/swig

If you are behind a proxy setup the git proxy settings before running the above commands

    git config --global http.proxy http://<username>:<password>@<proxy-server-url>:<port>

Since this is an anonymous download you will not be able to push any changes up to the project.
IoTivity is managed by the Linux Foundation.  If you are planning on contributing back to
IoTivity you will need to have a [Linux Foundation ID](https://identity.linuxfoundation.org/).
The Linux Foundation ID can then be used to log into the Gerrit server for IoTivity-Lite.
[gerrit.iotivity.org](https://gerrit.iotivity.org/gerrit/#/admin/projects/iotivity-lite)

Follow the instructions [here](https://wiki.iotivity.org/how_to_use_gerrit) to gain push access
to the project.

### Get SWIG
SWIG can be downloaded [here](http://swig.org/download.html).

SWIG can be installed on Ubuntu Linux using the following command.

    sudo apt-get install swig

The code was developed using SWIG version 3.0.  It has not been tested against SWIG version 4.0 that
was released when the swig branch was being developed.  Developers are welcome to use SWIG v4.0 and
share their experiences.

### Get Java Development Kit
The SWIG output should work with Java 6 and newer.  The Output has been tested against OpenJDK 1.8.
Due to licensing changes the output is no longer tested against Oracle Java.

Oracle Java 8 JDK can be
[downloaded here](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html).

AdoptOpenJDK can be [downloaded here](https://adoptopenjdk.net/installation.html)

On Ubuntu Linux OpenJDK can be downloaded using the following command.

    #To find out the avalible versions of OpenJDK
    apt-cache search openjdk
    sudo apt-get install openjdk-8-jdk
    # You may wish to choose a different version of openjdk
    # if you have installed multiple versions of Java you may need to switch
    # the active version using the update-java-alternatives tool.
    sudo apt-get install java-common
    update-java-alternatives

On Fedora Linux Install OpenJDK can be done using the following command

    sudo dnf install java-1.8.0-openjdk.x86_64
    # or use dnf install <openjdk-package-name>
    # if you have installed multiple versions of Java you may need to switch
    # the active version
    sudo alternatives --config java

To find different version of OpenJDK use the following command so see which
versions are available

    apt-cache search openjdk

### C Build tools
#### Android
##### Android SDK tools
Download the [Android SDK command line tools](https://developer.android.com/studio#downloads)

run `sdkmanager` found in the `tools/bin` directory to install the platform-tools and Android platform

    ./sdkmanager "platform-tools" "platforms;android-23"

if behind a proxy use the proxy connection options

    ./sdkmanager --proxy=<http|socks> --proxy_host=<host address> --proxy_port=<number> "platform-tools" "platforms;android-23"

##### Android NDK
Download the [Android NDK](https://developer.android.com/ndk/downloads/index.html)

Unzip downloaded package.

    cd <NDK>/build/tools
    sudo apt-get install python
    ./make_standalone_toolchain.py --arch <architecture> --api <level> --install-dir <path>

valid values for `--arch`
 - arm
 - arm64
 - x86
 - x86_64

The `make_standalone_toolchain` script only supports api level 16 and newer. We recommend using api
level 23 or newer.

For example:

    ./make_standalone_toolchain.py --arch arm --api 23 --install-dir ~/android-arm-23

Note: running the `make_standalone_toolchain.py` script may print a WARNING stating it is no longer
necessary.  This is expected.  At this time the make files expect the stand alone tool chain.

For further setup see:

https://developer.android.com/ndk/guides/standalone_toolchain.html

##### Android Studio (optional)
Developers wishing to use Android Studio can find details here:

[Android Studio](https://developer.android.com/studio)

#### Linux
For Ubuntu Linux GCC compiler was used

    sudo apt-get build-essential

#### Windows
For development on Windows Visual Studio 2015 was used.  The Visual Studio solution files have
been tested in newer version of Visual Studio and have been found to work.  Visual studio IDE
Community edition and Visual Studio Code should work but have not personally been tested.

Download Visual Studio [here](https://visualstudio.microsoft.com/).

### Make

    sudo apt-get install make

### Verify installation of needed tools
The scripts used assume all the needed tools are on PATH and are accessible without knowing the
location of the tool.

Run the following to verify each tool.  At this time there are no known issues limiting users to
the same version of the tools as were used for development.  Feel free to use the latest version of
all the development tools.

---
bash shell (windows only) For me this was installed with git

    sh --version

example of expected output

    GNU bash, version 4.4.12(2)-release (x86_64-pc-msys)
    Copyright (C) 2016 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

---
git

    git --version

example of expected output (newest version recommended)

    git version 2.20.1

---
SWIG

    swig -version

example of expected output (version 3.0 currently recommended)

    SWIG Version 3.0.12
    Compiled with g++ [x86_64-redhat-linux-gnu]
    Configured options: +pcre
    Please see http://www.swig.org for reporting bugs and further information

---
Java

    java -version
    javac -version

example of expected output

    openjdk version "1.8.0_191"
    OpenJDK RuntimeEnvironment (build 1.8.0_191-b12)
    OprnJDK 64-bit Server VM (build 25.191-b12, mixed mode)

    javac 1.8.0_191

Building IoTivity-Lite libraries
=================================================
### Building for Android
Navigate to `<iotivity-lite>/android/port`

    cd <iotivity-lite>/android/port

The Makefile uses then the Android NDK that was installed in the **Android NDK** section above.

Either set ANDROID_API and ANDROID_BASE in the Makefile or invoke like this:

    make NDK_HOME=/opt/android-ndk ANDROID_API=23

Example Usage:

    make IPV4=1 DEBUG=1

or

    make NDK_HOME=~/android-arm-23 ANDROID_API=23 IPV4=1 DEBUG=1

Copy the libiotivity-lite-jni.so to the appropriate jniLibs sub-directories for each project:

    cp libiotivity-lite-jni.so ../../swig/apps/android_simple_client/SimpleClient/app/src/main/jniLibs/armeabi/
    cp libiotivity-lite-jni.so ../../swig/apps/android_simple_server/SimpleServer/app/src/main/jniLibs/armeabi/

The Makefile also contains a version of these same build instructions.

### Building for Linux
Navigate to `<iotivity-lite>/port/linux`

    make IPV4=1 DEBUG=1 JAVA=1 IDD=1

### Building for Windows
Build the JNI shared library:

Navigate to `<iotivity-lite>/port/windows/vs2015` open the Visual Studio solution
`IoTivity-Lite.sln` file in Visual Studio.

Select the desired build options: Release/Debug, x86/x64.  Note the x86/x64 must match the
architecture of the Java VM that will be reading the library.  For example above when we run
`java -version` we get `Java HotSpot(TM) 64-Bit Server VM` this means we must select the x64
architecture for the build options.  In the Solution Explorer right click on the
`iotivity-lite-jni` project.  Select the `Build` option.

This will build
  - `IoTivity-Constrained.lib`
  - swig generated wraper code
  - `iotivity-lite-jni.dll`

On success the Output window should show:

    ========== Build: 2 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========

Build `iotivity-lite.jar` file:

    sh build-iotivity-lite.sh

Testing and Verifying
=================================================
All samples have the default out of the box behavior of IoTivity which means they are are not
onboarded or provisioned.  The default security will prevent the samples from communicating with
one another until onboarding and provisioning has been completed.  See the following section
**Onboarding and Provisioning** for instructions on using the onboarding tool that is part of
IoTivity-Lite.

### Building and Running Samples Android
A sample server and client can be found in `<iotivity-lite>/swig/apps/<sample>`

Note that gradlew will require a `local.properties` to exist or ANDROID_HOME to be defined.  An
installation of Android Studio should create the `local.properties` file.

example:

    export ANDROID_HOME=~/Android/sdk

To resolve any proxy issues reference [gradle user guide for proxy](https://docs.gradle.org/current/userguide/build_environment.html#sec:accessing_the_web_via_a_proxy)

The server sample is in `android_simple_server/SimpleServer`.  To build and install the sample
execute the following command:

### Method 1
    ./gradlew installDebug

### Method 2
    ./gradlew assembleDebug

To install

    cd app/build/outputs/apk
    adb install app-armeabi-debug.apk

The client sample is in `android_simple_client/SimpleClient`.  To build and install the sample
execute the following command:

### Method 1
    ./gradlew installDebug

### Method 2
    ./gradlew assembleDebug

To install

    cd app/build/outputs/apk
    adb install app-armeabi-debug.apk

### Building and Running Samples Linux
A sample server and client can be found in `<iotivity-lite>/swig/apps/<sample>`

The server sample is in `java_lite_simple_server`.  To build and run the sample execute the
following commands.

    ./build-simple-server-lite.sh
    ./run-simple-server-lite.sh

The client sample is in `java_lite_simple_client`.  To build and run the sample execute the
following commands.

    ./build-simple-client-lite.sh
    ./run-simple-client-lite.sh

### Building and Running Samples Windows
A sample server and client can be found in `<iotivity-lite>/swig/apps/<sample>`

The server sample is in `java_lite_simple_server`.  To build and run the sample execute the
following commands.

    sh build-simple-server-lite.sh
    run-simple-server-lite.cmd

The client sample is in `java_lite_simple_client`.  To build and run the sample execute the
following commands.

    sh build-simple-client-lite.sh
    run-simple-client-lite.cmd

Onboarding and Provisioning
=================================================
### Runing the onboarding tool

At this time there are three versions of the onboarding tool.  The command line C version, the
command line Java version, and the GUI Android version. Both command line versions are identical.
It does not matter which version of the onboarding tool is used.

The C version of the onboarding tool can be found in `<iotivity-lite>/port/linux` see Linux build
instructions.

A Java version of the onboarding-tool can be found in `<iotivity-lite>/swig/apps/java_onboarding_tool`

Assuming you have already followed the `Building for Linux` or `Building for Windows` build
instructions the following commands can be used to build and run the Java version of the onboarding
tool.

Linux:

    build-onboarding-tool-lite.sh
    run-onboarding-tool-lite.sh

Windows

    sh build-onboarding-tool-lite.sh
    run-onboarding-tool-lite.cmd

The Android version of the onboarding tool can be found in
`<iotivity-lite>/swig/apps/oc/android_on_boarding_tool`

It is built and installed using the same instructions as other Android samples documented above.

### Simple Step-by-Step guide for onboarding and provisioning

This guide assumes you are starting one discoverable device at a time. Multiple devices can be
discovered and onboarded at the same time however it becomes the responsibility of the user to
figure out which UUID belongs to which device.

Once you have successfully onboarded the samples the first time using the following step-by-step
options feel free to RESET the devices and play around with different provisioning options.

The below steps use the command line version of the onboarding tool. The steps for the Android
onboarding tool is very similar but is not described here.

### (Step 1) Onboard and Provision the Server

There are multiple methods to onboard and provision server and client samples.  Below is given one
of the many possible ways the this could be done.

 - start the server sample
 - start onboarding tool it will print a menu with many option
 - Type `1` **Enter** to _Discover un-owned devices_
 - Type `8` **Enter** to _Take ownership of device_
   - Type `0` **Enter**. If you have multiple unowned devices you will have to select the correct
     device from the list.
 - Type `4` **Enter** to _Discover owned devices_ the device you just took ownership of should be
   listed.
 - Type `13` **Enter** to _Provision ACE2_. There are many ways to properly provision the device.
   This will give instruction for using wildcard provisioning.
   - Type `0` **Enter**. If you have multiple unowned devices you will have to select the correct
     device from the list.
   - Type `1` **Enter** for an _auth-crypt_ ACE
   - Type `1` **Enter** in response to `Enter number of resources in this ACE:`
   - Type `0` **Enter** in response to `Have resource href? [0-No, 1-Yes]:`
   - Type `1` **Enter** in response to `Set wildcard resource? [0-No, 1-Yes]:`
   - Type `2` **Enter** to select the `[2]: All discoverable resources` option
   - Type `0` **Enter** in response to `Enter number of resource types [0-None]:`
   - Type `0` **Enter** in response to `Enter number of interfaces [0-None]`
   - Type `0` **Enter** for CREATE, `1` **Enter** for RETRIEVE, `1` **Enter** for UPDATE, `0`
     **Enter** for DELETE, and `1` **Enter** for NOTIFY.
   - `Successfully issued request to provision ACE` should be printed on the screen upon success

### (Step 2) Onboard the client
 - start the client sample
 - Type `1` **Enter** to _Discover un-owned devices_
 - Type `8` **Enter** to _Take ownership of device_
   - Type `0` **Enter**. If you have multiple unowned devices you will have to select the correct
     device from the list.
  - Type `2` **Enter** to _Discover owned devices_ the server and client should be listed

### (Step 3) Pair Server and Client
  - Type `12` **Enter** to _Provision pair-wise credentials_
  - Type `0` **Enter** `1` **Enter** to pair the client and server. If you have multiple owned
    devices you will have to select the correct devices from the list.

### (Step 4) Restart and Test
The samples should be onboarded and provisioned. Restart the server and then the client they should
discover each other and run without difficulty.

Layout of swig folder
=================================================
This contains an overview of the contents of the `<iotivity-lite>/swig` directory.  With a
summary of the contents of each directory.

    swig
    +-- apps
    |   +-- android_simple_client
    |   +-- android_simple_server
    |   +-- java_lite_simple_client
    |   |   +-- src
    |   +-- java_lite_simple_server
    |   |   +-- src
    +-- iotivity-lite-java
    |   +-- junit
    |   +-- src
    +-- java_lang
    +-- oc_java
    +-- swig_interfaces

- `apps`<br />
  Contains to client server samples.  The `java_lite` samples have been run and tested on Windows
  and Linux.  The `android` samples are the same samples with a really light UI for Android OS.
  The `java_lite` samples also contain project files for the Eclipse IDE if users wish to import
  the samples into that IDE. The `java_onboarding_tool` is a bear bones tool for onboarding and
  provisioning samples that have been built with security.
- `iotivity-lite-java`<br />
  Contains unit test code in the `junit` directory as well as an empty `src` directory.  The
  `src` directory will be populated with `*.java` files when the SWIG build commands are run.
  This also contains project files for the Eclipse IDE if user wishes to import the
  iotivity-lite code into Eclipse.
- `java_lang`<br />
  Contains build scripts needed to generate the Java language binding using SWIG.  With the
  exception of the scripts for building and running the samples all commands given in this README
  are run from the `java_lang` directory.
- `oc_java`<br />
  Contains Java files that are used by the SWIG output but not not generated as part of the SWIG
  build process.  Most of the files are Java interfaces used to handle callbacks and bitmask
  values.
- `swig_interfaces`<br />
  Contains the input files for the swig builder.  These files contain instructions for the SWIG
  builder.  It tells it which header files are being processed.  It instructs swig how to rename
  files from a C style name with underscores to a Java like lower camel case name.  It also
  instructs swig how to work with data types that it does not understand by default.  Data types
  like `oc_string_t`.  It also contains code that works around the fact that Java does not have a
  preprocessor so must handle many of the C macros differently.

Eclipse project files
=================================================
Where possible command line build scripts have been provided for building and running the code.
However much of the development was done using the Eclipse IDE.  The project files have been
committed so other developers can take advantage of the Eclipse IDE if they wish.

To open the project files:
 - Open Eclipse
 - select `File->Import..`
 - select `General->Existing Projects into Workspace`
 - click `Next>` button
 - click the `Browse..` button next to the `Select root directory:` text box
 - browse to the `<iotivity-lite>\swig` directory click `OK`
 - make sure the checkbox for the desired projects is checked.  Click `Finish`

Run the unit tests by right clicking on `iotivity-lite` project select `Run As -> JUnit Test`.
Selecting `Run As -> Java Application` will run the command line version of the unit tests.

Run samples by right clicking on the sample select
`Run As -> Java Application`.

If the code was previously built using the command-line build scripts you may get build warnings
indicating some class files can not be found.  Select `Project -> Clean...`.  Then right click on
the `iotivity-lite` project and select `Refresh`.  This should force the project to rebuild the
all the class files associated with the `iotivity-lite.jar` file.

Building Custom Android Applications
=================================================
These libraries and examples were built with Android API 23.  When creating a new Android project you
can choose the API level.  In building these examples, the native code libraries were copied to specific
directories in the project.  The project structure is:

```
    project/
    +--libs/
    |  +-- iotivity-lite.jar
    +--src/
       +-- main/
           +-- AndroidManifest.xml
           +-- java/
           +-- jniLibs/
               +-- armeabi/
               |   +-- libiotivity-lite-jni.so.so
               +-- x86-64/
                   +-- libiotivity-lite-jni.so.so
```

This structure is reflected in the app `build.gradle` file:

```
    android {
        .
        .
        .
        sourceSets {
            main {
                jniLibs.srcDirs = ["src/main/jniLibs", "$buildDir/native-libs"]
            }
        }
        splits {
            abi {
                enable true
                reset()
                include 'x86_64', 'armeabi'
                universalApk false
            }
        }
    }
    
    dependencies {
        compile fileTree(dir: 'libs', include: ['*.jar'])
        .
        .
        .
    }
```

To allow these example applications to work, permissions had to be granted in the `AndroidManifest.xml` file.

```
    <manifest ...>
    
        <uses-permission android:name="android.permission.INTERNET"/>
        <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
        <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
        <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE"/>
        <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
        <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE"/>
        
        <application
            .
            .
            .
        </application>
    
    </manifest>
```

Send Feedback
=================================================
Questions
[IoTivity-Lite Developer Mailing List](https://iotivity-dev@lists.iotivity.org)

Bugs
[Jira bug reporting website](https://jira.iotivity.org/projects/LITE)
