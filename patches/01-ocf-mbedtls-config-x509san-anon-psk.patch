diff --git a/include/mbedtls/check_config.h b/include/mbedtls/check_config.h
index ce97f6a35..3246f935a 100644
--- a/include/mbedtls/check_config.h
+++ b/include/mbedtls/check_config.h
@@ -259,6 +259,11 @@
 #error "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED defined, but not all prerequisites"
 #endif
 
+#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED) &&                 \
+    ( !defined(MBEDTLS_ECDH_C) )
+#error "MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED defined, but not all prerequisites"
+#endif
+
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) &&                 \
     ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_ECDSA_C) ||          \
       !defined(MBEDTLS_X509_CRT_PARSE_C) )
diff --git a/include/mbedtls/mbedtls_config.h b/include/mbedtls/mbedtls_config.h
index 0558ee001..b1d0f0121 100644
--- a/include/mbedtls/mbedtls_config.h
+++ b/include/mbedtls/mbedtls_config.h
@@ -33,6 +33,17 @@
  */
 //#define MBEDTLS_CONFIG_VERSION 0x03000000
 
+#include <oc_config.h>
+#include "port/oc_connectivity.h"
+#include "port/oc_assert.h"
+
+#define MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED
+#ifdef OC_PKI
+#define MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT
+#endif
+
+#define MBEDTLS_ALLOW_PRIVATE_ACCESS
+
 /**
  * \name SECTION: System support
  *
@@ -57,7 +68,7 @@
  *
  * Comment to disable the use of assembly code.
  */
-#define MBEDTLS_HAVE_ASM
+//#define MBEDTLS_HAVE_ASM
 
 /**
  * \def MBEDTLS_NO_UDBL_DIVISION
@@ -118,6 +129,8 @@
  */
 //#define MBEDTLS_HAVE_SSE2
 
+#ifdef OC_PKI
+#if defined(_WIN64) || defined(_WIN32) || defined(__APPLE__) || defined(__linux) || defined(__ANDROID__)
 /**
  * \def MBEDTLS_HAVE_TIME
  *
@@ -153,6 +166,8 @@
  * MBEDTLS_PLATFORM_GMTIME_R_ALT.
  */
 #define MBEDTLS_HAVE_TIME_DATE
+#endif /* One of the major OSs */
+#endif /* OC_PKI */
 
 /**
  * \def MBEDTLS_PLATFORM_MEMORY
@@ -176,7 +191,7 @@
  *
  * Enable this layer to allow use of alternative memory allocators.
  */
-//#define MBEDTLS_PLATFORM_MEMORY
+#define MBEDTLS_PLATFORM_MEMORY
 
 /**
  * \def MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
@@ -195,7 +210,7 @@
  * Uncomment to prevent default assignment of standard functions in the
  * platform layer.
  */
-//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
+#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
 
 /**
  * \def MBEDTLS_PLATFORM_EXIT_ALT
@@ -220,11 +235,11 @@
  * Uncomment a macro to enable alternate implementation of specific base
  * platform function
  */
-//#define MBEDTLS_PLATFORM_EXIT_ALT
+#define MBEDTLS_PLATFORM_EXIT_ALT
 //#define MBEDTLS_PLATFORM_TIME_ALT
 //#define MBEDTLS_PLATFORM_FPRINTF_ALT
 //#define MBEDTLS_PLATFORM_PRINTF_ALT
-//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
+#define MBEDTLS_PLATFORM_SNPRINTF_ALT
 //#define MBEDTLS_PLATFORM_VSNPRINTF_ALT
 //#define MBEDTLS_PLATFORM_NV_SEED_ALT
 //#define MBEDTLS_PLATFORM_SETUP_TEARDOWN_ALT
@@ -487,7 +502,7 @@
  * This option is independent of \c MBEDTLS_AES_FEWER_TABLES.
  *
  */
-//#define MBEDTLS_AES_ROM_TABLES
+#define MBEDTLS_AES_ROM_TABLES
 
 /**
  * \def MBEDTLS_AES_FEWER_TABLES
@@ -555,28 +570,28 @@
  *
  * Enable Cipher Feedback mode (CFB) for symmetric ciphers.
  */
-#define MBEDTLS_CIPHER_MODE_CFB
+//#define MBEDTLS_CIPHER_MODE_CFB
 
 /**
  * \def MBEDTLS_CIPHER_MODE_CTR
  *
  * Enable Counter Block Cipher mode (CTR) for symmetric ciphers.
  */
-#define MBEDTLS_CIPHER_MODE_CTR
+//#define MBEDTLS_CIPHER_MODE_CTR
 
 /**
  * \def MBEDTLS_CIPHER_MODE_OFB
  *
  * Enable Output Feedback mode (OFB) for symmetric ciphers.
  */
-#define MBEDTLS_CIPHER_MODE_OFB
+//#define MBEDTLS_CIPHER_MODE_OFB
 
 /**
  * \def MBEDTLS_CIPHER_MODE_XTS
  *
  * Enable Xor-encrypt-xor with ciphertext stealing mode (XTS) for AES.
  */
-#define MBEDTLS_CIPHER_MODE_XTS
+//#define MBEDTLS_CIPHER_MODE_XTS
 
 /**
  * \def MBEDTLS_CIPHER_NULL_CIPHER
@@ -621,10 +636,10 @@
  *
  * Enable padding modes in the cipher layer.
  */
-#define MBEDTLS_CIPHER_PADDING_PKCS7
-#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
-#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
-#define MBEDTLS_CIPHER_PADDING_ZEROS
+//#define MBEDTLS_CIPHER_PADDING_PKCS7
+//#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
+//#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
+//#define MBEDTLS_CIPHER_PADDING_ZEROS
 
 /** \def MBEDTLS_CTR_DRBG_USE_128_BIT_KEY
  *
@@ -642,20 +657,20 @@
  * Comment macros to disable the curve and functions for it
  */
 /* Short Weierstrass curves (supporting ECP, ECDH, ECDSA) */
-#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
 #define MBEDTLS_ECP_DP_SECP256R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
-#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
-#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
-#define MBEDTLS_ECP_DP_BP256R1_ENABLED
-#define MBEDTLS_ECP_DP_BP384R1_ENABLED
-#define MBEDTLS_ECP_DP_BP512R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
+//#define MBEDTLS_ECP_DP_BP256R1_ENABLED
+//#define MBEDTLS_ECP_DP_BP384R1_ENABLED
+//#define MBEDTLS_ECP_DP_BP512R1_ENABLED
 /* Montgomery curves (supporting ECP) */
-#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
-#define MBEDTLS_ECP_DP_CURVE448_ENABLED
+//#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
+//#define MBEDTLS_ECP_DP_CURVE448_ENABLED
 
 /**
  * \def MBEDTLS_ECP_NIST_OPTIM
@@ -666,7 +681,7 @@
  *
  * Comment this macro to disable NIST curves optimisation.
  */
-#define MBEDTLS_ECP_NIST_OPTIM
+//#define MBEDTLS_ECP_NIST_OPTIM
 
 /**
  * \def MBEDTLS_ECP_RESTARTABLE
@@ -704,7 +719,7 @@
  *
  * Comment this macro to disable deterministic ECDSA.
  */
-#define MBEDTLS_ECDSA_DETERMINISTIC
+//#define MBEDTLS_ECDSA_DETERMINISTIC
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
@@ -753,7 +768,7 @@
  *             See dhm.h for more details.
  *
  */
-#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
+//#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
@@ -794,7 +809,7 @@
  *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
  *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
  */
-#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
+//#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
@@ -819,7 +834,7 @@
  *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
  *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
  */
-#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
+//#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
@@ -851,7 +866,7 @@
  *             See dhm.h for more details.
  *
  */
-#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
+//#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
@@ -874,7 +889,9 @@
  *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
  *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
  */
+#ifdef OC_PKI
 #define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
+#endif
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
@@ -896,7 +913,9 @@
  *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
  *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
  */
+#ifdef OC_PKI
 #define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
+#endif
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
@@ -918,7 +937,9 @@
  *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
  *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
  */
+#ifdef OC_PKI
 #define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
+#endif
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
@@ -940,7 +961,7 @@
  *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
  *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
  */
-#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
+//#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
@@ -973,7 +994,7 @@
  *
  * Disable if you only need to support RFC 5915 + 5480 key formats.
  */
-#define MBEDTLS_PK_PARSE_EC_EXTENDED
+//#define MBEDTLS_PK_PARSE_EC_EXTENDED
 
 /**
  * \def MBEDTLS_ERROR_STRERROR_DUMMY
@@ -988,7 +1009,7 @@
  * Disable if you run into name conflicts and want to really remove the
  * mbedtls_strerror()
  */
-#define MBEDTLS_ERROR_STRERROR_DUMMY
+//#define MBEDTLS_ERROR_STRERROR_DUMMY
 
 /**
  * \def MBEDTLS_GENPRIME
@@ -997,14 +1018,14 @@
  *
  * Requires: MBEDTLS_BIGNUM_C
  */
-#define MBEDTLS_GENPRIME
+//#define MBEDTLS_GENPRIME
 
 /**
  * \def MBEDTLS_FS_IO
  *
  * Enable functions that use the filesystem.
  */
-#define MBEDTLS_FS_IO
+//#define MBEDTLS_FS_IO
 
 /**
  * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
@@ -1117,7 +1138,7 @@
  *
  * Comment this macro to disable support for external private RSA keys.
  */
-#define MBEDTLS_PK_RSA_ALT_SUPPORT
+//#define MBEDTLS_PK_RSA_ALT_SUPPORT
 
 /**
  * \def MBEDTLS_PKCS1_V15
@@ -1139,7 +1160,7 @@
  *
  * This enables support for RSAES-OAEP and RSASSA-PSS operations.
  */
-#define MBEDTLS_PKCS1_V21
+//#define MBEDTLS_PKCS1_V21
 
 /** \def MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS
  *
@@ -1265,7 +1286,7 @@
  *
  * Enable the checkup functions (*_self_test).
  */
-#define MBEDTLS_SELF_TEST
+//#define MBEDTLS_SELF_TEST
 
 /**
  * \def MBEDTLS_SHA256_SMALLER
@@ -1371,7 +1392,7 @@
  *
  * Comment to disable the context serialization APIs.
  */
-#define MBEDTLS_SSL_CONTEXT_SERIALIZATION
+//#define MBEDTLS_SSL_CONTEXT_SERIALIZATION
 
 /**
  * \def MBEDTLS_SSL_DEBUG_ALL
@@ -1403,7 +1424,7 @@
  *
  * Comment this macro to disable support for Encrypt-then-MAC
  */
-#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
+//#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
 
 /** \def MBEDTLS_SSL_EXTENDED_MASTER_SECRET
  *
@@ -1463,7 +1484,7 @@
  *          configuration of this extension).
  *
  */
-#define MBEDTLS_SSL_RENEGOTIATION
+//#define MBEDTLS_SSL_RENEGOTIATION
 
 /**
  * \def MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
@@ -1543,7 +1564,7 @@
  *
  * Comment this macro to disable support for ALPN.
  */
-#define MBEDTLS_SSL_ALPN
+//#define MBEDTLS_SSL_ALPN
 
 /**
  * \def MBEDTLS_SSL_DTLS_ANTI_REPLAY
@@ -1623,7 +1644,7 @@
  *
  * Comment this to disable support for clients reusing the source port.
  */
-#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
+//#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
 
 /**
  * \def MBEDTLS_SSL_SESSION_TICKETS
@@ -1637,7 +1658,7 @@
  *
  * Comment this macro to disable support for SSL session tickets
  */
-#define MBEDTLS_SSL_SESSION_TICKETS
+//#define MBEDTLS_SSL_SESSION_TICKETS
 
 /**
  * \def MBEDTLS_SSL_SERVER_NAME_INDICATION
@@ -1648,7 +1669,7 @@
  *
  * Comment this macro to disable support for server name indication in SSL
  */
-#define MBEDTLS_SSL_SERVER_NAME_INDICATION
+//#define MBEDTLS_SSL_SERVER_NAME_INDICATION
 
 /**
  * \def MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH
@@ -1788,7 +1809,7 @@
  *
  * Comment this to disable run-time checking and save ROM space
  */
-#define MBEDTLS_VERSION_FEATURES
+//#define MBEDTLS_VERSION_FEATURES
 
 /**
  * \def MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK
@@ -1828,7 +1849,7 @@
  *
  * Comment this macro to disallow using RSASSA-PSS in certificates.
  */
-#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
+//#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
 /* \} name SECTION: mbed TLS feature support */
 
 /**
@@ -1850,7 +1871,7 @@
  *
  * This modules adds support for the AES-NI instructions on x86-64
  */
-#define MBEDTLS_AESNI_C
+//#define MBEDTLS_AESNI_C
 
 /**
  * \def MBEDTLS_AES_C
@@ -1939,7 +1960,9 @@
  *          library/pkcs5.c
  *          library/pkparse.c
  */
+#ifdef OC_PKI
 #define MBEDTLS_ASN1_PARSE_C
+#endif
 
 /**
  * \def MBEDTLS_ASN1_WRITE_C
@@ -1953,7 +1976,9 @@
  *          library/x509write_crt.c
  *          library/x509write_csr.c
  */
+#ifdef OC_PKI
 #define MBEDTLS_ASN1_WRITE_C
+#endif
 
 /**
  * \def MBEDTLS_BASE64_C
@@ -1965,7 +1990,9 @@
  *
  * This module is required for PEM support (required by X.509).
  */
+#ifdef OC_PKI
 #define MBEDTLS_BASE64_C
+#endif
 
 /**
  * \def MBEDTLS_BIGNUM_C
@@ -2037,7 +2064,7 @@
  *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
  *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
  */
-#define MBEDTLS_CAMELLIA_C
+//#define MBEDTLS_CAMELLIA_C
 
 /**
  * \def MBEDTLS_ARIA_C
@@ -2103,7 +2130,9 @@
  * This module enables the AES-CCM ciphersuites, if other requisites are
  * enabled as well.
  */
+#ifdef OC_PKI
 #define MBEDTLS_CCM_C
+#endif
 
 /**
  * \def MBEDTLS_CHACHA20_C
@@ -2112,7 +2141,7 @@
  *
  * Module:  library/chacha20.c
  */
-#define MBEDTLS_CHACHA20_C
+//#define MBEDTLS_CHACHA20_C
 
 /**
  * \def MBEDTLS_CHACHAPOLY_C
@@ -2123,7 +2152,7 @@
  *
  * This module requires: MBEDTLS_CHACHA20_C, MBEDTLS_POLY1305_C
  */
-#define MBEDTLS_CHACHAPOLY_C
+//#define MBEDTLS_CHACHAPOLY_C
 
 /**
  * \def MBEDTLS_CIPHER_C
@@ -2187,7 +2216,9 @@
  *
  * This module provides debugging functions.
  */
+#ifdef OC_DEBUG
 #define MBEDTLS_DEBUG_C
+#endif
 
 /**
  * \def MBEDTLS_DES_C
@@ -2203,7 +2234,7 @@
  * \warning   DES is considered a weak cipher and its use constitutes a
  *            security risk. We recommend considering stronger ciphers instead.
  */
-#define MBEDTLS_DES_C
+//#define MBEDTLS_DES_C
 
 /**
  * \def MBEDTLS_DHM_C
@@ -2224,7 +2255,7 @@
  *             See dhm.h for more details.
  *
  */
-#define MBEDTLS_DHM_C
+//#define MBEDTLS_DHM_C
 
 /**
  * \def MBEDTLS_ECDH_C
@@ -2257,7 +2288,9 @@
  *           and at least one MBEDTLS_ECP_DP_XXX_ENABLED for a
  *           short Weierstrass curve.
  */
+#ifdef OC_PKI
 #define MBEDTLS_ECDSA_C
+#endif
 
 /**
  * \def MBEDTLS_ECJPAKE_C
@@ -2316,7 +2349,9 @@
  *
  * This module enables mbedtls_strerror().
  */
+#ifdef OC_DEBUG
 #define MBEDTLS_ERROR_C
+#endif
 
 /**
  * \def MBEDTLS_GCM_C
@@ -2330,7 +2365,9 @@
  * This module enables the AES-GCM and CAMELLIA-GCM ciphersuites, if other
  * requisites are enabled as well.
  */
+#ifdef OC_PKI
 #define MBEDTLS_GCM_C
+#endif
 
 /**
  * \def MBEDTLS_HKDF_C
@@ -2345,7 +2382,7 @@
  * This module adds support for the Hashed Message Authentication Code
  * (HMAC)-based key derivation function (HKDF).
  */
-#define MBEDTLS_HKDF_C
+//#define MBEDTLS_HKDF_C
 
 /**
  * \def MBEDTLS_HMAC_DRBG_C
@@ -2359,7 +2396,7 @@
  *
  * Uncomment to enable the HMAC_DRBG random number geerator.
  */
-#define MBEDTLS_HMAC_DRBG_C
+//#define MBEDTLS_HMAC_DRBG_C
 
 /**
  * \def MBEDTLS_NIST_KW_C
@@ -2405,7 +2442,7 @@
  *            it, and considering stronger message digests instead.
  *
  */
-#define MBEDTLS_MD5_C
+//#define MBEDTLS_MD5_C
 
 /**
  * \def MBEDTLS_MEMORY_BUFFER_ALLOC_C
@@ -2440,7 +2477,7 @@
  *
  * This module provides networking routines.
  */
-#define MBEDTLS_NET_C
+//#define MBEDTLS_NET_C
 
 /**
  * \def MBEDTLS_OID_C
@@ -2463,7 +2500,9 @@
  *
  * This modules translates between OIDs and internal values.
  */
+#ifdef OC_PKI
 #define MBEDTLS_OID_C
+#endif
 
 /**
  * \def MBEDTLS_PADLOCK_C
@@ -2477,7 +2516,7 @@
  *
  * This modules adds support for the VIA PadLock on x86.
  */
-#define MBEDTLS_PADLOCK_C
+//#define MBEDTLS_PADLOCK_C
 
 /**
  * \def MBEDTLS_PEM_PARSE_C
@@ -2495,7 +2534,9 @@
  *
  * This modules adds support for decoding / parsing PEM files.
  */
+#ifdef OC_PKI
 #define MBEDTLS_PEM_PARSE_C
+#endif
 
 /**
  * \def MBEDTLS_PEM_WRITE_C
@@ -2511,7 +2552,9 @@
  *
  * This modules adds support for encoding / writing PEM files.
  */
+#ifdef OC_PKI
 #define MBEDTLS_PEM_WRITE_C
+#endif
 
 /**
  * \def MBEDTLS_PK_C
@@ -2527,7 +2570,9 @@
  *
  * Uncomment to enable generic public key wrappers.
  */
+#ifdef OC_PKI
 #define MBEDTLS_PK_C
+#endif
 
 /**
  * \def MBEDTLS_PK_PARSE_C
@@ -2542,7 +2587,9 @@
  *
  * Uncomment to enable generic public key parse functions.
  */
+#ifdef OC_PKI
 #define MBEDTLS_PK_PARSE_C
+#endif
 
 /**
  * \def MBEDTLS_PK_WRITE_C
@@ -2556,7 +2603,9 @@
  *
  * Uncomment to enable generic public key write functions.
  */
+#ifdef OC_PKI
 #define MBEDTLS_PK_WRITE_C
+#endif
 
 /**
  * \def MBEDTLS_PKCS5_C
@@ -2584,7 +2633,7 @@
  *
  * This module enables PKCS#12 functions.
  */
-#define MBEDTLS_PKCS12_C
+//#define MBEDTLS_PKCS12_C
 
 /**
  * \def MBEDTLS_PLATFORM_C
@@ -2614,7 +2663,7 @@
  * Module:  library/poly1305.c
  * Caller:  library/chachapoly.c
  */
-#define MBEDTLS_POLY1305_C
+//#define MBEDTLS_POLY1305_C
 
 /**
  * \def MBEDTLS_PSA_CRYPTO_C
@@ -2628,7 +2677,7 @@
  *           or MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG.
  *
  */
-#define MBEDTLS_PSA_CRYPTO_C
+//#define MBEDTLS_PSA_CRYPTO_C
 
 /**
  * \def MBEDTLS_PSA_CRYPTO_SE_C
@@ -2657,7 +2706,7 @@
  *           either MBEDTLS_PSA_ITS_FILE_C or a native implementation of
  *           the PSA ITS interface
  */
-#define MBEDTLS_PSA_CRYPTO_STORAGE_C
+//#define MBEDTLS_PSA_CRYPTO_STORAGE_C
 
 /**
  * \def MBEDTLS_PSA_ITS_FILE_C
@@ -2669,7 +2718,7 @@
  *
  * Requires: MBEDTLS_FS_IO
  */
-#define MBEDTLS_PSA_ITS_FILE_C
+//#define MBEDTLS_PSA_ITS_FILE_C
 
 /**
  * \def MBEDTLS_RIPEMD160_C
@@ -2680,7 +2729,7 @@
  * Caller:  library/md.c
  *
  */
-#define MBEDTLS_RIPEMD160_C
+//#define MBEDTLS_RIPEMD160_C
 
 /**
  * \def MBEDTLS_RSA_C
@@ -2699,7 +2748,9 @@
  *
  * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C
  */
+#ifdef OC_PKI
 #define MBEDTLS_RSA_C
+#endif
 
 /**
  * \def MBEDTLS_SHA1_C
@@ -2721,7 +2772,7 @@
  *            on it, and considering stronger message digests instead.
  *
  */
-#define MBEDTLS_SHA1_C
+//#define MBEDTLS_SHA1_C
 
 /**
  * \def MBEDTLS_SHA224_C
@@ -2800,7 +2851,7 @@
  *
  * Requires: MBEDTLS_SSL_CACHE_C
  */
-#define MBEDTLS_SSL_CACHE_C
+//#define MBEDTLS_SSL_CACHE_C
 
 /**
  * \def MBEDTLS_SSL_COOKIE_C
@@ -2822,7 +2873,7 @@
  *
  * Requires: MBEDTLS_CIPHER_C
  */
-#define MBEDTLS_SSL_TICKET_C
+//#define MBEDTLS_SSL_TICKET_C
 
 /**
  * \def MBEDTLS_SSL_CLI_C
@@ -2908,7 +2959,7 @@
  *
  * Module:  library/timing.c
  */
-#define MBEDTLS_TIMING_C
+//#define MBEDTLS_TIMING_C
 
 /**
  * \def MBEDTLS_VERSION_C
@@ -2919,7 +2970,7 @@
  *
  * This module provides run-time version information.
  */
-#define MBEDTLS_VERSION_C
+//#define MBEDTLS_VERSION_C
 
 /**
  * \def MBEDTLS_X509_USE_C
@@ -2936,7 +2987,9 @@
  *
  * This module is required for the X.509 parsing modules.
  */
+#ifdef OC_PKI
 #define MBEDTLS_X509_USE_C
+#endif
 
 /**
  * \def MBEDTLS_X509_CRT_PARSE_C
@@ -2952,7 +3005,9 @@
  *
  * This module is required for X.509 certificate parsing.
  */
+#ifdef OC_PKI
 #define MBEDTLS_X509_CRT_PARSE_C
+#endif
 
 /**
  * \def MBEDTLS_X509_CRL_PARSE_C
@@ -2966,7 +3021,7 @@
  *
  * This module is required for X.509 CRL parsing.
  */
-#define MBEDTLS_X509_CRL_PARSE_C
+//#define MBEDTLS_X509_CRL_PARSE_C
 
 /**
  * \def MBEDTLS_X509_CSR_PARSE_C
@@ -2980,7 +3035,9 @@
  *
  * This module is used for reading X.509 certificate request.
  */
+#ifdef OC_PKI
 #define MBEDTLS_X509_CSR_PARSE_C
+#endif
 
 /**
  * \def MBEDTLS_X509_CREATE_C
@@ -2993,7 +3050,9 @@
  *
  * This module is the basis for creating X.509 certificates and CSRs.
  */
+#ifdef OC_PKI
 #define MBEDTLS_X509_CREATE_C
+#endif
 
 /**
  * \def MBEDTLS_X509_CRT_WRITE_C
@@ -3006,7 +3065,9 @@
  *
  * This module is required for X.509 certificate creation.
  */
+#ifdef OC_PKI
 #define MBEDTLS_X509_CRT_WRITE_C
+#endif
 
 /**
  * \def MBEDTLS_X509_CSR_WRITE_C
@@ -3019,7 +3080,9 @@
  *
  * This module is required for X.509 certificate request writing.
  */
+#ifdef OC_PKI
 #define MBEDTLS_X509_CSR_WRITE_C
+#endif
 
 /* \} name SECTION: mbed TLS modules */
 
@@ -3060,7 +3123,12 @@
 //#define MBEDTLS_ECP_FIXED_POINT_OPTIM      1 /**< Enable fixed-point speed-up */
 
 /* Entropy options */
-//#define MBEDTLS_ENTROPY_MAX_SOURCES                20 /**< Maximum number of sources supported */
+/*
+ * You should adjust this to the exact number of sources you're using: default
+ * is the "platform_entropy_poll" source, but you may want to add other ones
+ * Minimum is 2 for the entropy test suite.
+ */
+#define MBEDTLS_ENTROPY_MAX_SOURCES                2 /**< Maximum number of sources supported */
 //#define MBEDTLS_ENTROPY_MAX_GATHER                128 /**< Maximum amount requested from entropy sources */
 //#define MBEDTLS_ENTROPY_MIN_HARDWARE               32 /**< Default minimum number of bytes required for the hardware entropy source mbedtls_hardware_poll() before entropy is released */
 
@@ -3069,14 +3137,19 @@
 
 /* Platform options */
 //#define MBEDTLS_PLATFORM_STD_MEM_HDR   <stdlib.h> /**< Header to include if MBEDTLS_PLATFORM_NO_STD_FUNCTIONS is defined. Don't define if no header is needed. */
-//#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
-//#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
-//#define MBEDTLS_PLATFORM_STD_EXIT            exit /**< Default exit to use, can be undefined */
+#ifdef OC_DYNAMIC_ALLOCATION
+#include <stdlib.h>
+#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
+#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
+#else /* OC_DYNAMIC_ALLOCATION */
+#define MBEDTLS_MEMORY_BUFFER_ALLOC_C             /**< Default allocator to use, can be undefined */
+#endif /* !OC_DYNAMIC_ALLOCATION */
+#define MBEDTLS_PLATFORM_STD_EXIT            oc_exit/**< Default exit to use, can be undefined */
 //#define MBEDTLS_PLATFORM_STD_TIME            time /**< Default time to use, can be undefined. MBEDTLS_HAVE_TIME must be enabled */
 //#define MBEDTLS_PLATFORM_STD_FPRINTF      fprintf /**< Default fprintf to use, can be undefined */
 //#define MBEDTLS_PLATFORM_STD_PRINTF        printf /**< Default printf to use, can be undefined */
 /* Note: your snprintf must correctly zero-terminate the buffer! */
-//#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
+#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
 //#define MBEDTLS_PLATFORM_STD_EXIT_SUCCESS       0 /**< Default exit value to use, can be undefined */
 //#define MBEDTLS_PLATFORM_STD_EXIT_FAILURE       1 /**< Default exit value to use, can be undefined */
 //#define MBEDTLS_PLATFORM_STD_NV_SEED_READ   mbedtls_platform_std_nv_seed_read /**< Default nv_seed_read function to use, can be undefined */
@@ -3171,6 +3244,9 @@
  * Uncomment to set the maximum plaintext size of the incoming I/O buffer.
  */
 //#define MBEDTLS_SSL_IN_CONTENT_LEN              16384
+#ifndef OC_DYNAMIC_ALLOCATION
+#define MBEDTLS_SSL_IN_CONTENT_LEN             (OC_PDU_SIZE)
+#endif /* !OC_DYNAMIC_ALLOCATION */
 
 /** \def MBEDTLS_SSL_CID_IN_LEN_MAX
  *
@@ -3221,6 +3297,9 @@
  * Uncomment to set the maximum plaintext size of the outgoing I/O buffer.
  */
 //#define MBEDTLS_SSL_OUT_CONTENT_LEN             16384
+#ifndef OC_DYNAMIC_ALLOCATION
+#define MBEDTLS_SSL_OUT_CONTENT_LEN             (OC_PDU_SIZE)
+#endif /* !OC_DYNAMIC_ALLOCATION */
 
 /** \def MBEDTLS_SSL_DTLS_MAX_BUFFERING
  *
@@ -3240,6 +3319,7 @@
 //#define MBEDTLS_SSL_DTLS_MAX_BUFFERING             32768
 
 //#define MBEDTLS_PSK_MAX_LEN               32 /**< Max size of TLS pre-shared keys, in bytes (default 256 bits) */
+#define MBEDTLS_PSK_MAX_LEN                 32 /**< Max size of TLS pre-shared keys, in bytes (default 256 bits) */
 //#define MBEDTLS_SSL_COOKIE_TIMEOUT        60 /**< Default expiration delay of DTLS cookies, in seconds if HAVE_TIME, or in number of cookies issued */
 
 /** \def MBEDTLS_TLS_EXT_CID
diff --git a/include/mbedtls/net_sockets.h b/include/mbedtls/net_sockets.h
index 0c754b122..a7bc61354 100644
--- a/include/mbedtls/net_sockets.h
+++ b/include/mbedtls/net_sockets.h
@@ -41,6 +41,10 @@
 
 #include "mbedtls/build_info.h"
 
+#if defined(MBEDTLS_HAVE_WINSOCK2)
+#include <winsock2.h>
+#endif
+
 #include "mbedtls/ssl.h"
 
 #include <stddef.h>
@@ -81,6 +85,19 @@
 #define MBEDTLS_NET_POLL_READ  1 /**< Used in \c mbedtls_net_poll to check for pending data  */
 #define MBEDTLS_NET_POLL_WRITE 2 /**< Used in \c mbedtls_net_poll to check if write possible */
 
+/**
+ * Socket types and invalid values differ between platforms.
+ */
+#if defined(MBEDTLS_HAVE_WINSOCK2)
+#define MBEDTLS_INVALID_SOCKET INVALID_SOCKET
+
+typedef SOCKET mbedtls_socket;
+#else
+#define MBEDTLS_INVALID_SOCKET -1
+
+typedef int mbedtls_socket;
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -100,7 +117,7 @@ typedef struct mbedtls_net_context
      * On other platforms, it may have a different type, have a different
      * meaning, or be absent altogether.
      */
-    int fd;
+    mbedtls_socket fd;
 }
 mbedtls_net_context;
 
diff --git a/include/mbedtls/ssl.h b/include/mbedtls/ssl.h
index 072ebbe46..332cf064b 100644
--- a/include/mbedtls/ssl.h
+++ b/include/mbedtls/ssl.h
@@ -581,7 +581,8 @@ union mbedtls_ssl_premaster_secret
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)    || \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)  || \
     defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)     || \
-    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)   || \
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
     unsigned char _pms_ecdh[MBEDTLS_ECP_MAX_BYTES];    /* RFC 4492 5.10 */
 #endif
 #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
@@ -1342,6 +1343,10 @@ struct mbedtls_ssl_config
     mbedtls_ssl_key_cert *MBEDTLS_PRIVATE(key_cert); /*!< own certificate/key pair(s)        */
     mbedtls_x509_crt *MBEDTLS_PRIVATE(ca_chain);     /*!< trusted CAs                        */
     mbedtls_x509_crl *MBEDTLS_PRIVATE(ca_crl);       /*!< trusted CAs CRLs                   */
+    const char *MBEDTLS_PRIVATE(client_oid);         /*!< OID to check on client certs       */
+    size_t MBEDTLS_PRIVATE(client_oid_len);          /*!< length of client OID               */
+    const char *MBEDTLS_PRIVATE(server_oid);         /*!< OID to check on server certs       */
+    size_t MBEDTLS_PRIVATE(server_oid_len);          /*!< length of server OID               */
 #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
     mbedtls_x509_crt_ca_cb_t MBEDTLS_PRIVATE(f_ca_cb);
     void *MBEDTLS_PRIVATE(p_ca_cb);
@@ -2964,6 +2969,47 @@ void mbedtls_ssl_conf_ca_cb( mbedtls_ssl_config *conf,
 int mbedtls_ssl_conf_own_cert( mbedtls_ssl_config *conf,
                               mbedtls_x509_crt *own_cert,
                               mbedtls_pk_context *pk_key );
+
+#if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
+/**
+ * \brief                  Set custom EKU OIDs to be checked on certificates during TLS negotiation,
+ *                         and for selecting suitable certificates for TLS negotation.
+ *
+ * \note                   By default, if this function is not called, clients will
+ *                         check for the server authentication EKU (1.3.6.1.5.5.7.3.1) in
+ *                         a server's certificate, and servers will check for the
+ *                         client authentication EKU (1.3.6.1.5.5.7.3.2) if a client
+ *                         presents a certificate.
+ *
+ * \param conf             SSL configuration
+ * \param client_oid       OID to check for when verifying client certificates as a server.
+ *                         This must be an MBEDTLS_OID_* constant from oid.h, or a custom OID
+ *                         supplied by the caller. If a custom OID is used, it must be provided in
+ *                         its ASN.1 encoding; human-readable dotted numeric strings are not supported.
+ *                         Additionally, callers using custom OID buffers must ensure those buffers remain
+ *                         live while this SSL configuration is live. Passing NULL will
+ *                         disable EKU checking of client certificates.
+ * \param client_oid_len   The length of client_oid, not counting a terminating NULL if present; for constants
+ *                         from oid.h, this can be obtained with MBEDTLS_OID_SIZE(x) where x is the OID constant.
+ *                         If client_oid is NULL, this must be zero.
+ * \param server_oid       OID to check for when verifying server certificates as a client.
+ *                         This must be an MBEDTLS_OID_* constant from oid.h, or a custom OID
+ *                         supplied by the caller. If a custom OID is used, it must be provided in
+ *                         its ASN.1 encoding; human-readable dotted numeric strings are not supported.
+ *                         Additionally, callers using custom OID buffers must ensure those buffers remain
+ *                         live while this SSL configuration is live. Passing NULL will
+ *                         disable EKU checking of server certificates.
+ * \param server_oid_len   The length of server_oid not counting a terminating NULL if present; for constants
+ *                         from oid.h, this can be obtained with MBEDTLS_OID_SIZE(x) where x is the OID constant.
+ *                         If client_oid is NULL, this must be zero.
+ *
+ * \return                 0 on success or MBEDTLS_ERR_SSL_BAD_INPUT_DATA for invalid arguments.
+ *                         On failure, existing behavior is unchanged.
+ */
+int mbedtls_ssl_conf_ekus( mbedtls_ssl_config *conf,
+                           const char *client_oid, size_t client_oid_len,
+                           const char *server_oid, size_t server_oid_len );
+#endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE */
 #endif /* MBEDTLS_X509_CRT_PARSE_C */
 
 #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
diff --git a/include/mbedtls/ssl_ciphersuites.h b/include/mbedtls/ssl_ciphersuites.h
index 18e7c9876..4c1b67b11 100644
--- a/include/mbedtls/ssl_ciphersuites.h
+++ b/include/mbedtls/ssl_ciphersuites.h
@@ -137,6 +137,8 @@ extern "C" {
 #define MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256     0xC031 /**< TLS 1.2 */
 #define MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384     0xC032 /**< TLS 1.2 */
 
+#define MBEDTLS_TLS_ECDH_ANON_WITH_AES_128_CBC_SHA256    0xFF00 /**< TLS 1.2 */
+
 #define MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA       0xC035
 #define MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA       0xC036
 #define MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256    0xC037
@@ -279,6 +281,7 @@ typedef enum {
     MBEDTLS_KEY_EXCHANGE_ECDH_RSA,
     MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA,
     MBEDTLS_KEY_EXCHANGE_ECJPAKE,
+    MBEDTLS_KEY_EXCHANGE_ECDH_ANON,
 } mbedtls_key_exchange_type_t;
 
 /* Key exchanges using a certificate */
@@ -405,6 +408,7 @@ static inline int mbedtls_ssl_ciphersuite_has_pfs( const mbedtls_ssl_ciphersuite
         case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
         case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
         case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
+        case MBEDTLS_KEY_EXCHANGE_ECDH_ANON:
             return( 1 );
 
         default:
@@ -504,6 +508,7 @@ static inline int mbedtls_ssl_ciphersuite_uses_ecdhe( const mbedtls_ssl_ciphersu
         case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
         case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
         case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
+        case MBEDTLS_KEY_EXCHANGE_ECDH_ANON:
             return( 1 );
 
         default:
diff --git a/include/mbedtls/x509_crt.h b/include/mbedtls/x509_crt.h
index 3c11a9989..5d61db701 100644
--- a/include/mbedtls/x509_crt.h
+++ b/include/mbedtls/x509_crt.h
@@ -43,6 +43,31 @@ extern "C" {
  * \{
  */
 
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+typedef enum
+{
+    /* Don't use the value zero in this enum, because we use zero to denote an unset struct. */
+    MBEDTLS_X509_GENERALNAME_DNSNAME = 1,
+    MBEDTLS_X509_GENERALNAME_DIRECTORYNAME
+} mbedtls_x509_general_name_choice;
+
+typedef struct mbedtls_x509_general_name
+{
+    mbedtls_x509_general_name_choice name_type;
+    union
+    {
+        mbedtls_x509_buf dns_name;
+        mbedtls_x509_name *directory_name;
+    } name;
+} mbedtls_x509_general_name;
+
+typedef struct mbedtls_x509_general_names
+{
+    mbedtls_x509_general_name general_name;
+    struct mbedtls_x509_general_names *next;
+} mbedtls_x509_general_names;
+#endif
+
 /**
  * Container for an X.509 certificate. The certificate may be chained.
  *
@@ -76,7 +101,11 @@ typedef struct mbedtls_x509_crt
     mbedtls_x509_buf issuer_id;         /**< Optional X.509 v2/v3 issuer unique identifier. */
     mbedtls_x509_buf subject_id;        /**< Optional X.509 v2/v3 subject unique identifier. */
     mbedtls_x509_buf v3_ext;            /**< Optional X.509 v3 extensions.  */
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    mbedtls_x509_general_names subject_alt_names; /**< Optional list of Subject Alternative Names (Only dNSName and directoryName supported). */
+#else
     mbedtls_x509_sequence subject_alt_names;    /**< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName and OtherName are listed). */
+#endif
 
     mbedtls_x509_sequence certificate_policies; /**< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed). */
 
@@ -1138,6 +1167,21 @@ int mbedtls_x509write_crt_set_key_usage( mbedtls_x509write_cert *ctx,
 int mbedtls_x509write_crt_set_ns_cert_type( mbedtls_x509write_cert *ctx,
                                     unsigned char ns_cert_type );
 
+
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+/**
+ * \brief           Set the subject alternative name extension
+ *
+ * \param ctx       CRT context to use
+ * \param names     subject alternative names. For each dNSName element, the tag field of the dns_name
+ *                  member does not need to be set and will be ignored.
+ *
+ * \return          0 if successful, or a specific error code
+ */
+int mbedtls_x509write_crt_set_subject_alt_names( mbedtls_x509write_cert *ctx,
+                                                 const mbedtls_x509_general_names *names );
+#endif /* MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT */
+
 /**
  * \brief           Free the contents of a CRT write context
  *
diff --git a/library/bignum.c b/library/bignum.c
index e47e25917..e91a4dd68 100644
--- a/library/bignum.c
+++ b/library/bignum.c
@@ -1563,9 +1563,9 @@ static mbedtls_mpi_uint mbedtls_int_div_int( mbedtls_mpi_uint u1,
      */
     if( 0 == d || u1 >= d )
     {
-        if (r != NULL) *r = ~0;
+        if (r != NULL) *r = (mbedtls_mpi_uint) ~0;
 
-        return ( ~0 );
+        return ( (mbedtls_mpi_uint) ~0 );
     }
 
 #if defined(MBEDTLS_HAVE_UDBL)
@@ -1704,7 +1704,7 @@ int mbedtls_mpi_div_mpi( mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A,
     for( i = n; i > t ; i-- )
     {
         if( X.p[i] >= Y.p[t] )
-            Z.p[i - t - 1] = ~0;
+            Z.p[i - t - 1] = (mbedtls_mpi_uint) ~0;
         else
         {
             Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
diff --git a/library/ctr_drbg.c b/library/ctr_drbg.c
index 93a7cdcd1..7450dd39b 100644
--- a/library/ctr_drbg.c
+++ b/library/ctr_drbg.c
@@ -161,7 +161,7 @@ static int block_cipher_df( unsigned char *output,
     buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;
 
     for( i = 0; i < MBEDTLS_CTR_DRBG_KEYSIZE; i++ )
-        key[i] = i;
+        key[i] = (unsigned char)i;
 
     if( ( ret = mbedtls_aes_setkey_enc( &aes_ctx, key,
                                         MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )
diff --git a/library/entropy_poll.c b/library/entropy_poll.c
index 058c307df..650cea9e0 100644
--- a/library/entropy_poll.c
+++ b/library/entropy_poll.c
@@ -42,12 +42,32 @@
 #if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)
 
 #if !defined(unix) && !defined(__unix__) && !defined(__unix) && \
-    !defined(__APPLE__) && !defined(_WIN32) && !defined(__QNXNTO__) && \
+    !defined(__APPLE__) && !defined(_WIN32) && !defined(__OC_RANDOM) && !defined(__QNXNTO__) && \
     !defined(__HAIKU__) && !defined(__midipix__)
 #error "Platform entropy sources only work on Unix and Windows, see MBEDTLS_NO_PLATFORM_ENTROPY in mbedtls_config.h"
 #endif
 
-#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
+#ifdef __OC_RANDOM
+#include <string.h>
+#include "port/oc_random.h"
+
+int mbedtls_platform_entropy_poll( void *data,
+                           unsigned char *output, size_t len, size_t *olen )
+{
+    (void) data;
+    *olen = 0;
+    do {
+        unsigned int val = oc_random_value();
+        size_t l = (len > sizeof(val))?sizeof(val):len;
+        memcpy(output + *olen, &val, l);
+        len -= l;
+        *olen += l;
+    } while (len > 0);
+
+    return 0;
+}
+
+#elif defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
 
 #if !defined(_WIN32_WINNT)
 #define _WIN32_WINNT 0x0400
diff --git a/library/net_sockets.c b/library/net_sockets.c
index 17a9e4a57..892f2da69 100644
--- a/library/net_sockets.c
+++ b/library/net_sockets.c
@@ -140,7 +140,7 @@ static int net_prepare( void )
  * If for_select != 0, check whether the file descriptor is within the range
  * allowed for fd_set used for the FD_xxx macros and the select() function.
  */
-static int check_fd( int fd, int for_select )
+static int check_fd( mbedtls_socket fd, int for_select )
 {
     if( fd < 0 )
         return( MBEDTLS_ERR_NET_INVALID_CONTEXT );
@@ -165,7 +165,7 @@ static int check_fd( int fd, int for_select )
  */
 void mbedtls_net_init( mbedtls_net_context *ctx )
 {
-    ctx->fd = -1;
+    ctx->fd = MBEDTLS_INVALID_SOCKET;
 }
 
 /*
@@ -193,8 +193,7 @@ int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host,
     ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;
     for( cur = addr_list; cur != NULL; cur = cur->ai_next )
     {
-        ctx->fd = (int) socket( cur->ai_family, cur->ai_socktype,
-                            cur->ai_protocol );
+        ctx->fd = socket( cur->ai_family, cur->ai_socktype, cur->ai_protocol );
         if( ctx->fd < 0 )
         {
             ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
@@ -340,7 +339,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
                         mbedtls_net_context *client_ctx,
                         void *client_ip, size_t buf_size, size_t *ip_len )
 {
-    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    mbedtls_socket ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     int type;
 
     struct sockaddr_storage client_addr;
@@ -366,7 +365,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
     if( type == SOCK_STREAM )
     {
         /* TCP: actual accept() */
-        ret = client_ctx->fd = (int) accept( bind_ctx->fd,
+        ret = client_ctx->fd = accept( bind_ctx->fd,
                                              (struct sockaddr *) &client_addr, &n );
     }
     else
@@ -374,8 +373,8 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
         /* UDP: wait for a message, but keep it in the queue */
         char buf[1] = { 0 };
 
-        ret = (int) recvfrom( bind_ctx->fd, buf, sizeof( buf ), MSG_PEEK,
-                        (struct sockaddr *) &client_addr, &n );
+        ret = recvfrom( bind_ctx->fd, buf, sizeof( buf ),
+                            MSG_PEEK, (struct sockaddr *) &client_addr, &n );
 
 #if defined(_WIN32)
         if( ret == SOCKET_ERROR &&
@@ -387,7 +386,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
 #endif
     }
 
-    if( ret < 0 )
+    if( ret == MBEDTLS_INVALID_SOCKET )
     {
         if( net_would_block( bind_ctx ) != 0 )
             return( MBEDTLS_ERR_SSL_WANT_READ );
@@ -406,13 +405,14 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
             return( MBEDTLS_ERR_NET_ACCEPT_FAILED );
 
         client_ctx->fd = bind_ctx->fd;
-        bind_ctx->fd   = -1; /* In case we exit early */
+
+        bind_ctx->fd = MBEDTLS_INVALID_SOCKET; /* In case we exit early */
 
         n = sizeof( struct sockaddr_storage );
         if( getsockname( client_ctx->fd,
                          (struct sockaddr *) &local_addr, &n ) != 0 ||
-            ( bind_ctx->fd = (int) socket( local_addr.ss_family,
-                                           SOCK_DGRAM, IPPROTO_UDP ) ) < 0 ||
+            ( bind_ctx->fd = socket( local_addr.ss_family,
+                                          SOCK_DGRAM, IPPROTO_UDP ) ) < 0 ||
             setsockopt( bind_ctx->fd, SOL_SOCKET, SO_REUSEADDR,
                         (const char *) &one, sizeof( one ) ) != 0 )
         {
@@ -489,7 +489,7 @@ int mbedtls_net_poll( mbedtls_net_context *ctx, uint32_t rw, uint32_t timeout )
     fd_set read_fds;
     fd_set write_fds;
 
-    int fd = ctx->fd;
+    mbedtls_socket fd = ctx->fd;
 
     ret = check_fd( fd, 1 );
     if( ret != 0 )
@@ -570,7 +570,7 @@ void mbedtls_net_usleep( unsigned long usec )
 int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len )
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
-    int fd = ((mbedtls_net_context *) ctx)->fd;
+    mbedtls_socket fd = ((mbedtls_net_context *) ctx)->fd;
 
     ret = check_fd( fd, 0 );
     if( ret != 0 )
@@ -610,7 +610,7 @@ int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf,
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     struct timeval tv;
     fd_set read_fds;
-    int fd = ((mbedtls_net_context *) ctx)->fd;
+    mbedtls_socket fd = ((mbedtls_net_context *) ctx)->fd;
 
     ret = check_fd( fd, 1 );
     if( ret != 0 )
@@ -622,7 +622,7 @@ int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf,
     tv.tv_sec  = timeout / 1000;
     tv.tv_usec = ( timeout % 1000 ) * 1000;
 
-    ret = select( fd + 1, &read_fds, NULL, NULL, timeout == 0 ? NULL : &tv );
+    ret = select( (int)fd + 1, &read_fds, NULL, NULL, timeout == 0 ? NULL : &tv );
 
     /* Zero fds ready means we timed out */
     if( ret == 0 )
@@ -652,7 +652,7 @@ int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf,
 int mbedtls_net_send( void *ctx, const unsigned char *buf, size_t len )
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
-    int fd = ((mbedtls_net_context *) ctx)->fd;
+    mbedtls_socket fd = ((mbedtls_net_context *) ctx)->fd;
 
     ret = check_fd( fd, 0 );
     if( ret != 0 )
@@ -701,13 +701,13 @@ void mbedtls_net_close( mbedtls_net_context *ctx )
  */
 void mbedtls_net_free( mbedtls_net_context *ctx )
 {
-    if( ctx->fd == -1 )
+    if( ctx->fd == MBEDTLS_INVALID_SOCKET )
         return;
 
     shutdown( ctx->fd, 2 );
     close( ctx->fd );
 
-    ctx->fd = -1;
+    ctx->fd = MBEDTLS_INVALID_SOCKET;
 }
 
 #endif /* MBEDTLS_NET_C */
diff --git a/library/rsa.c b/library/rsa.c
index 36f487f3a..8b49d275e 100644
--- a/library/rsa.c
+++ b/library/rsa.c
@@ -1810,6 +1810,9 @@ static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,
      *                                 TAG-NULL + LEN [ NULL ] ]
      *                 TAG-OCTET + LEN [ HASH ] ]
      */
+     if ( hashlen > 127 )
+        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+
     *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
     *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
     *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
diff --git a/library/ssl_ciphersuites.c b/library/ssl_ciphersuites.c
index 62588dc2e..ab3c4bdad 100644
--- a/library/ssl_ciphersuites.c
+++ b/library/ssl_ciphersuites.c
@@ -112,6 +112,7 @@ static const int ciphersuite_preference[] =
     MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
     MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,
     MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_ECDH_ANON_WITH_AES_128_CBC_SHA256,
 
     /* All CAMELLIA-128 ephemeral suites */
     MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256,
@@ -526,6 +527,22 @@ static const mbedtls_ssl_ciphersuite_t ciphersuite_definitions[] =
 #endif /* MBEDTLS_CIPHER_NULL_CIPHER */
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
 
+
+#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
+#if defined(MBEDTLS_AES_C)
+#if defined(MBEDTLS_SHA256_C)
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+    { MBEDTLS_TLS_ECDH_ANON_WITH_AES_128_CBC_SHA256, "TLS-ECDH-ANON-WITH-AES-128-CBC-SHA256",
+      MBEDTLS_CIPHER_AES_128_CBC, MBEDTLS_MD_SHA256, MBEDTLS_KEY_EXCHANGE_ECDH_ANON,
+      MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3,
+      MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3,
+      0 },
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+#endif /* MBEDTLS_SHA256_C */
+#endif /* MBEDTLS_AES_C */
+#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
+
+
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)
 #if defined(MBEDTLS_AES_C)
 #if defined(MBEDTLS_SHA1_C)
@@ -2118,6 +2135,7 @@ int mbedtls_ssl_ciphersuite_uses_ec( const mbedtls_ssl_ciphersuite_t *info )
         case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
         case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
         case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
+        case MBEDTLS_KEY_EXCHANGE_ECDH_ANON:
             return( 1 );
 
         default:
diff --git a/library/ssl_cli.c b/library/ssl_cli.c
index 32d496913..1cc21251f 100644
--- a/library/ssl_cli.c
+++ b/library/ssl_cli.c
@@ -538,7 +538,7 @@ static int ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
     *p++ = 0x00;
     *p++ = 1;
 
-    *p++ = ssl->conf->mfl_code;
+    *p++ = (unsigned char)ssl->conf->mfl_code;
 
     *olen = 5;
 
@@ -2477,7 +2477,8 @@ static int ssl_parse_server_dh_params( mbedtls_ssl_context *ssl,
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
-    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) ||                    \
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
 static int ssl_check_server_ecdh_params( const mbedtls_ssl_context *ssl )
 {
     const mbedtls_ecp_curve_info *curve_info;
@@ -2514,7 +2515,8 @@ static int ssl_check_server_ecdh_params( const mbedtls_ssl_context *ssl )
           MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
-          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
+          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED ||
+          MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
 
 #if defined(MBEDTLS_USE_PSA_CRYPTO) &&                           \
         ( defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||     \
@@ -2580,7 +2582,8 @@ static int ssl_parse_server_ecdh_params_psa( mbedtls_ssl_context *ssl,
 
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
-    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
+    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
 static int ssl_parse_server_ecdh_params( mbedtls_ssl_context *ssl,
                                          unsigned char **p,
                                          unsigned char *end )
@@ -2617,16 +2620,24 @@ static int ssl_parse_server_ecdh_params( mbedtls_ssl_context *ssl,
 }
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
-          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
+          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED  ||
+          MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
 
 #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
 static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
                                       unsigned char **p,
                                       unsigned char *end )
 {
-    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
-    uint16_t  len;
-    ((void) ssl);
+    int ret = 0;
+    size_t n;
+
+    if( ssl->conf->f_psk == NULL &&
+        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
+          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
+    {
+        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no pre-shared key" ) );
+        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
+    }
 
     /*
      * PSK parameters:
@@ -2639,10 +2650,14 @@ static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
             ( "bad server key exchange message (psk_identity_hint length)" ) );
         return( MBEDTLS_ERR_SSL_DECODE_ERROR );
     }
-    len = (*p)[0] << 8 | (*p)[1];
+    n = (*p)[0] << 8 | (*p)[1];
     *p += 2;
 
-    if( end - (*p) < len )
+    if( n == 0 )
+    {
+        return ( 0 );
+    }
+    if( n < 1 || n > 65535 || *p + n > end )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1,
             ( "bad server key exchange message (psk_identity_hint length)" ) );
@@ -2654,10 +2669,38 @@ static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
      * PSK to be provisionned on the client. This could be changed later if
      * someone needs that feature.
      */
-    *p += len;
-    ret = 0;
+    if( ssl->conf->f_psk != NULL )
+    {
+        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )
+            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
+    }
+    else
+    {
+        /* Identity is not a big secret since clients send it in the clear,
+         * but treat it carefully anyway, just in case */
+        if( n != ssl->conf->psk_identity_len ||
+            mbedtls_ct_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )
+        {
+            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
+        }
+    }
 
-    return( ret );
+    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )
+    {
+        MBEDTLS_SSL_DEBUG_BUF( 3, "Unknown PSK identity", *p, n );
+        if( ( ret = mbedtls_ssl_send_alert_message( ssl,
+                              MBEDTLS_SSL_ALERT_LEVEL_FATAL,
+                              MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY ) ) != 0 )
+        {
+            return( ret );
+        }
+
+        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );
+    }
+
+    *p += n;
+
+    return( 0 );
 }
 #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
 
@@ -3038,10 +3081,12 @@ start_processing:
               MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ) */
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \
-    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
+    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
-        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
+        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
+        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ANON )
     {
         if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )
         {
@@ -3056,7 +3101,8 @@ start_processing:
     else
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||
-          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
+          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
+          MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
     {
@@ -3082,19 +3128,21 @@ start_processing:
 #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
     if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )
     {
+#if !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
         size_t sig_len, hashlen;
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
         unsigned char hash[PSA_HASH_MAX_SIZE];
 #else
         unsigned char hash[MBEDTLS_MD_MAX_SIZE];
-#endif
-        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
-        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
+#endif // MBEDTLS_USE_PSA_CRYPTO
         unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
         size_t params_len = p - params;
         void *rs_ctx = NULL;
-
         mbedtls_pk_context * peer_pk;
+#endif /* !MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
+        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
+        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
+
 
         /*
          * Handle the digitally-signed structure
@@ -3133,6 +3181,13 @@ start_processing:
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
         }
 
+// Anonymous cipher suite without sign, ecdh param only
+#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
+        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ANON )
+        {
+            goto exit;
+        }
+#else
         /*
          * Read signature
          */
@@ -3236,6 +3291,7 @@ start_processing:
          * operations like ECDHE. */
         mbedtls_pk_free( peer_pk );
 #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
+#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
     }
 #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
 
@@ -3615,11 +3671,13 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
     defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
-    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) ||                    \
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
-        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
+        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA ||
+        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ANON)
     {
         /*
          * ECDH key exchange -- send client public value
@@ -3685,7 +3743,8 @@ ecdh_calc_secret:
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
-          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
+          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED ||
+          MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
 #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
     if( mbedtls_ssl_ciphersuite_uses_psk( ciphersuite_info ) )
     {
diff --git a/library/ssl_misc.h b/library/ssl_misc.h
index 40e4aaff8..d3c91b7f0 100644
--- a/library/ssl_misc.h
+++ b/library/ssl_misc.h
@@ -1335,6 +1335,8 @@ static inline mbedtls_x509_crt *mbedtls_ssl_own_cert( mbedtls_ssl_context *ssl )
 int mbedtls_ssl_check_cert_usage( const mbedtls_x509_crt *cert,
                           const mbedtls_ssl_ciphersuite_t *ciphersuite,
                           int cert_endpoint,
+                          const char *client_oid, size_t client_oid_len,
+                          const char *server_oid, size_t server_oid_len,
                           uint32_t *flags );
 #endif /* MBEDTLS_X509_CRT_PARSE_C */
 
diff --git a/library/ssl_srv.c b/library/ssl_srv.c
index f34f2de30..7a623f9f7 100644
--- a/library/ssl_srv.c
+++ b/library/ssl_srv.c
@@ -952,7 +952,10 @@ static int ssl_pick_cert( mbedtls_ssl_context *ssl,
          * and decrypting with the same RSA key.
          */
         if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,
-                                  MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )
+                                  MBEDTLS_SSL_IS_SERVER,
+                                  ssl->conf->client_oid, ssl->conf->client_oid_len,
+                                  ssl->conf->server_oid, ssl->conf->server_oid_len,                                                            
+                                  &flags ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: "
                                 "(extended) key usage extension" ) );
@@ -2962,8 +2965,10 @@ static int ssl_prepare_server_key_exchange( mbedtls_ssl_context *ssl,
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
     {
-        ssl->out_msg[ssl->out_msglen++] = 0x00;
-        ssl->out_msg[ssl->out_msglen++] = 0x00;
+        ssl->out_msg[ssl->out_msglen++] = (unsigned char)( ssl->conf->psk_identity_len >> 8 );
+        ssl->out_msg[ssl->out_msglen++] = (unsigned char)( ssl->conf->psk_identity_len      );
+        memcpy(ssl->out_msg+ssl->out_msglen, ssl->conf->psk_identity, ssl->conf->psk_identity_len);
+        ssl->out_msglen += ssl->conf->psk_identity_len;
     }
 #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||
           MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
@@ -3755,11 +3760,13 @@ static int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
     defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
-    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) ||                    \
+    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
-        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
+        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA ||
+        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ANON )
     {
         if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
                                       p, end - p) ) != 0 )
diff --git a/library/ssl_tls.c b/library/ssl_tls.c
index d868e4965..69f1e8d68 100644
--- a/library/ssl_tls.c
+++ b/library/ssl_tls.c
@@ -2148,6 +2148,8 @@ static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl,
     if( mbedtls_ssl_check_cert_usage( chain,
                                       ciphersuite_info,
                                       ! ssl->conf->endpoint,
+                                      ssl->conf->client_oid, ssl->conf->client_oid_len,
+                                      ssl->conf->server_oid, ssl->conf->server_oid_len,                                   
                                       &ssl->session_negotiate->verify_result ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (usage extensions)" ) );
@@ -3653,6 +3655,26 @@ int mbedtls_ssl_conf_own_cert( mbedtls_ssl_config *conf,
     return( ssl_append_key_cert( &conf->key_cert, own_cert, pk_key ) );
 }
 
+int mbedtls_ssl_conf_ekus( mbedtls_ssl_config *conf,
+                           const char *client_oid, size_t client_oid_len,
+                           const char *server_oid, size_t server_oid_len )
+{
+    if( ( client_oid_len == 0 && client_oid )  ||
+        ( client_oid_len != 0 && !client_oid ) ||
+        ( server_oid_len == 0 && server_oid )  ||
+        ( server_oid_len != 0 && !server_oid ) )
+    {
+        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
+    }
+
+    conf->client_oid = client_oid;
+    conf->client_oid_len = client_oid_len;
+    conf->server_oid = server_oid;
+    conf->server_oid_len = server_oid_len;
+
+    return( 0 );
+}
+
 void mbedtls_ssl_conf_ca_chain( mbedtls_ssl_config *conf,
                                mbedtls_x509_crt *ca_chain,
                                mbedtls_x509_crl *ca_crl )
@@ -4208,14 +4230,14 @@ void mbedtls_ssl_get_dtls_srtp_negotiation_result( const mbedtls_ssl_context *ss
 
 void mbedtls_ssl_conf_max_version( mbedtls_ssl_config *conf, int major, int minor )
 {
-    conf->max_major_ver = major;
-    conf->max_minor_ver = minor;
+    conf->max_major_ver = (unsigned char)major;
+    conf->max_minor_ver = (unsigned char)minor;
 }
 
 void mbedtls_ssl_conf_min_version( mbedtls_ssl_config *conf, int major, int minor )
 {
-    conf->min_major_ver = major;
-    conf->min_minor_ver = minor;
+    conf->min_major_ver = (unsigned char)major;
+    conf->min_minor_ver = (unsigned char)minor;
 }
 
 #if defined(MBEDTLS_SSL_SRV_C)
@@ -6458,6 +6480,13 @@ int mbedtls_ssl_config_defaults( mbedtls_ssl_config *conf,
     mbedtls_ssl_conf_endpoint( conf, endpoint );
     mbedtls_ssl_conf_transport( conf, transport );
 
+#if defined(MBEDTLS_X509_CRT_PARSE_C)
+    conf->client_oid = MBEDTLS_OID_CLIENT_AUTH;
+    conf->client_oid_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CLIENT_AUTH );
+    conf->server_oid = MBEDTLS_OID_SERVER_AUTH;
+    conf->server_oid_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_SERVER_AUTH );
+#endif
+
     /*
      * Things that are common to all presets
      */
@@ -6861,6 +6890,8 @@ int mbedtls_ssl_check_sig_hash( const mbedtls_ssl_context *ssl,
 int mbedtls_ssl_check_cert_usage( const mbedtls_x509_crt *cert,
                           const mbedtls_ssl_ciphersuite_t *ciphersuite,
                           int cert_endpoint,
+                          const char *client_oid, size_t client_oid_len,
+                          const char *server_oid, size_t server_oid_len,
                           uint32_t *flags )
 {
     int ret = 0;
@@ -6895,6 +6926,7 @@ int mbedtls_ssl_check_cert_usage( const mbedtls_x509_crt *cert,
             case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
             case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
             case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
+            case MBEDTLS_KEY_EXCHANGE_ECDH_ANON:
                 usage = 0;
         }
     }
@@ -6912,13 +6944,13 @@ int mbedtls_ssl_check_cert_usage( const mbedtls_x509_crt *cert,
 
     if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
     {
-        ext_oid = MBEDTLS_OID_SERVER_AUTH;
-        ext_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_SERVER_AUTH );
+        ext_oid = server_oid;
+        ext_len = server_oid_len;
     }
     else
     {
-        ext_oid = MBEDTLS_OID_CLIENT_AUTH;
-        ext_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CLIENT_AUTH );
+        ext_oid = client_oid;
+        ext_len = client_oid_len;
     }
 
     if( mbedtls_x509_crt_check_extended_key_usage( cert, ext_oid, ext_len ) != 0 )
diff --git a/library/version_features.c b/library/version_features.c
index dfc3212f4..346ead939 100644
--- a/library/version_features.c
+++ b/library/version_features.c
@@ -342,6 +342,9 @@ static const char * const features[] = {
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)
     "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED",
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED */
+#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED)
+    "MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED",
+#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_ANON_ENABLED */
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
     "MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED",
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
@@ -525,6 +528,9 @@ static const char * const features[] = {
 #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
     "MBEDTLS_X509_RSASSA_PSS_SUPPORT",
 #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    "MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT",
+#endif /* MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT */
 #if defined(MBEDTLS_AESNI_C)
     "MBEDTLS_AESNI_C",
 #endif /* MBEDTLS_AESNI_C */
diff --git a/library/x509_create.c b/library/x509_create.c
index 056bbaa78..30cca52ae 100644
--- a/library/x509_create.c
+++ b/library/x509_create.c
@@ -216,7 +216,7 @@ int mbedtls_x509_set_extension( mbedtls_asn1_named_data **head, const char *oid,
         return( MBEDTLS_ERR_X509_ALLOC_FAILED );
     }
 
-    cur->val.p[0] = critical;
+    cur->val.p[0] = critical == 0 ? 0 : 1;
     memcpy( cur->val.p + 1, val, val_len );
 
     return( 0 );
diff --git a/library/x509_crt.c b/library/x509_crt.c
index c8654445d..c0d58e5ba 100644
--- a/library/x509_crt.c
+++ b/library/x509_crt.c
@@ -65,6 +65,7 @@
 
 #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
 #include <windows.h>
+#include <intsafe.h>
 #else
 #include <time.h>
 #endif
@@ -642,16 +643,31 @@ static int x509_get_ext_key_usage( unsigned char **p,
  *
  * NOTE: we list all types, but only use dNSName and otherName
  * of type HwModuleName, as defined in RFC 4108, at this point.
+ * NOTE: If MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT is not defined, we only parse and use dNSName.
+ * If it is defined, we parse and use all supported types, which are currently dNSName and directoryName.
  */
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
 static int x509_get_subject_alt_name( unsigned char **p,
                                       const unsigned char *end,
-                                      mbedtls_x509_sequence *subject_alt_name )
+                                      mbedtls_x509_general_names *subject_alt_name )
+
+#else
+ static int x509_get_subject_alt_name( unsigned char **p,
+                                       const unsigned char *end,
+                                       mbedtls_x509_sequence *subject_alt_name )
+#endif
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len, tag_len;
-    mbedtls_asn1_buf *buf;
     unsigned char tag;
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    mbedtls_x509_general_names *cur = subject_alt_name;
+    mbedtls_x509_general_name general_name;
+    size_t name_len;
+#else
+    mbedtls_asn1_buf *buf;
     mbedtls_asn1_sequence *cur = subject_alt_name;
+#endif
 
     /* Get main sequence tag */
     if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
@@ -678,6 +694,49 @@ static int x509_get_subject_alt_name( unsigned char **p,
             return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
                     MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) );
         }
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+        memset( &general_name, 0, sizeof( general_name ) );
+        switch ( tag )
+        {
+        case ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ): /* dNSName */
+            general_name.name_type = MBEDTLS_X509_GENERALNAME_DNSNAME;
+            general_name.name.dns_name.tag = tag;
+            general_name.name.dns_name.p = *p;
+            general_name.name.dns_name.len = tag_len;
+            *p += tag_len;
+            break;
+        case ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 4 ): /* directoryName */
+            general_name.name_type = MBEDTLS_X509_GENERALNAME_DIRECTORYNAME;
+            if( ( ret = mbedtls_asn1_get_tag( p, end, &name_len,
+                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
+                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
+            general_name.name.directory_name = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );
+            if ( general_name.name.directory_name == NULL )
+                return( MBEDTLS_ERR_X509_ALLOC_FAILED );
+            if( ( ret = mbedtls_x509_get_name( p, *p + name_len, general_name.name.directory_name ) ) != 0 )
+                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
+            break;
+        default:
+            *p += tag_len;
+            continue;
+        }
+
+        if( cur->general_name.name_type != 0 )
+        {
+            if( cur->next != NULL )
+                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );
+
+            cur->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_general_names ) );
+
+            if( cur->next == NULL )
+                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
+                        MBEDTLS_ERR_ASN1_ALLOC_FAILED );
+
+            cur = cur->next;
+        }
+
+        memcpy( &cur->general_name, &general_name, sizeof( general_name ) );
+#else
 
         /*
          * Check that the SAN is structured correctly.
@@ -723,6 +782,7 @@ static int x509_get_subject_alt_name( unsigned char **p,
         buf->p = *p;
         buf->len = tag_len;
         *p += buf->len;
+#endif
     }
 
     /* Set final sequence entry's next pointer to NULL */
@@ -1568,6 +1628,7 @@ int mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path )
     char filename[MAX_PATH];
     char *p;
     size_t len = strlen( path );
+    int lengthAsInt = 0;
 
     WIN32_FIND_DATAW file_data;
     HANDLE hFind;
@@ -1582,7 +1643,10 @@ int mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path )
     p = filename + len;
     filename[len++] = '*';
 
-    w_ret = MultiByteToWideChar( CP_ACP, 0, filename, (int)len, szDir,
+    if ( FAILED ( SizeTToInt( len, &lengthAsInt ) ) )
+        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );
+
+    w_ret = MultiByteToWideChar( CP_ACP, 0, filename, lengthAsInt, szDir,
                                  MAX_PATH - 3 );
     if( w_ret == 0 )
         return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
@@ -1599,8 +1663,11 @@ int mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path )
         if( file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
             continue;
 
+        if ( FAILED( SizeTToInt( wcslen( file_data.cFileName ), &lengthAsInt ) ) )
+            return( MBEDTLS_ERR_X509_FILE_IO_ERROR );
+
         w_ret = WideCharToMultiByte( CP_ACP, 0, file_data.cFileName,
-                                     lstrlenW( file_data.cFileName ),
+                                     lengthAsInt,
                                      p, (int) len - 1,
                                      NULL, NULL );
         if( w_ret == 0 )
@@ -1697,6 +1764,7 @@ cleanup:
  * NOTE: we currently only parse and use otherName of type HwModuleName,
  * as defined in RFC 4108.
  */
+#if !defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
 static int x509_get_other_name( const mbedtls_x509_buf *subject_alt_name,
                                 mbedtls_x509_san_other_name *other_name )
 {
@@ -1828,8 +1896,102 @@ int mbedtls_x509_parse_subject_alt_name( const mbedtls_x509_buf *san_buf,
     }
     return( 0 );
 }
+#endif /* !MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT */
 
 #if !defined(MBEDTLS_X509_REMOVE_INFO)
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+static const char x509_directory_name_label[] = "directoryName=(";
+static const char x509_directory_name_epilogue[] = ")";
+
+/* Length of label constant excluding terminating null. */
+#define LABEL_LEN( label ) ( sizeof ( label ) - 1 )
+
+static int x509_info_subject_alt_name( char **buf, size_t *size,
+                                       const mbedtls_x509_general_names *subject_alt_name, const char *prefix )
+{
+    (void) prefix;
+    int ret;
+    size_t i;
+    size_t n = *size;
+    char *p = *buf;
+    const mbedtls_x509_general_names *cur = subject_alt_name;
+    const char *sep = "";
+    size_t sep_len = 0;
+
+    while( cur != NULL )
+    {
+        switch ( cur->general_name.name_type )
+        {
+        case MBEDTLS_X509_GENERALNAME_DNSNAME:
+            i = cur->general_name.name.dns_name.len + sep_len;
+
+            if( i >= n )
+            {
+                *p = '\0';
+                return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
+            }
+
+            n -= i;
+            for( i = 0; i < sep_len; i++ )
+                *p++ = sep[i];
+            for( i = 0; i < cur->general_name.name.dns_name.len; i++ )
+                *p++ = cur->general_name.name.dns_name.p[i];
+
+            break;
+ 
+        case MBEDTLS_X509_GENERALNAME_DIRECTORYNAME:
+            i = sep_len + LABEL_LEN( x509_directory_name_label );
+            if( i >= n )
+            {
+                *p = '\0';
+                return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
+            }
+
+            n -= i;
+            for( i = 0; i < sep_len; i++ )
+                *p++ = sep[i];
+            for( i = 0; i < LABEL_LEN( x509_directory_name_label ); i++ )
+                *p++ = x509_directory_name_label[i];
+
+            ret = mbedtls_x509_dn_gets( p, n, cur->general_name.name.directory_name );
+            if( ret < 0 || ( (size_t) ret ) >= n )
+            {
+                *p = '\0';
+                return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
+            }
+
+            n -= ret;
+            p += ret;
+
+            i = LABEL_LEN( x509_directory_name_epilogue );
+
+            if( i >= n )
+            {
+                *p = '\0';
+                return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
+            }
+
+            n -= i;
+            for( i = 0; i < LABEL_LEN( x509_directory_name_epilogue ); i++ )
+                *p++ = x509_directory_name_epilogue[i];
+
+            break;
+        }
+
+        sep = ", ";
+        sep_len = 2;
+
+        cur = cur->next;
+    }
+
+    *p = '\0';
+
+    *size = n;
+    *buf = p;
+
+    return( 0 );
+}
+#else
 static int x509_info_subject_alt_name( char **buf, size_t *size,
                                        const mbedtls_x509_sequence
                                                     *subject_alt_name,
@@ -1942,6 +2104,7 @@ static int x509_info_subject_alt_name( char **buf, size_t *size,
 
     return( 0 );
 }
+#endif
 
 #define PRINT_ITEM(i)                           \
     {                                           \
@@ -2999,6 +3162,7 @@ static int x509_crt_check_cn( const mbedtls_x509_buf *name,
 /*
  * Check for SAN match, see RFC 5280 Section 4.2.1.6
  */
+#if !defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
 static int x509_crt_check_san( const mbedtls_x509_buf *name,
                                const char *cn, size_t cn_len )
 {
@@ -3014,6 +3178,7 @@ static int x509_crt_check_san( const mbedtls_x509_buf *name,
     /* Unrecognized type */
     return( -1 );
 }
+#endif
 
 /*
  * Verify the requested CN - only call this if cn is not NULL!
@@ -3023,11 +3188,34 @@ static void x509_crt_verify_name( const mbedtls_x509_crt *crt,
                                   uint32_t *flags )
 {
     const mbedtls_x509_name *name;
-    const mbedtls_x509_sequence *cur;
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    const mbedtls_x509_general_names *cur;
+#else
+     const mbedtls_x509_sequence *cur;
+#endif
     size_t cn_len = strlen( cn );
 
     if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
     {
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+        for( cur = (const mbedtls_x509_general_names *)&crt->subject_alt_names; cur != NULL; cur = cur->next )
+        {
+	    /* Only consider dNSName subject alternative names for this check; ignore other types. */
+	    if ( cur->general_name.name_type == MBEDTLS_X509_GENERALNAME_DNSNAME )
+	    {
+	        if ( cur->general_name.name.dns_name.len == cn_len &&
+		     x509_memcasecmp( cn, cur->general_name.name.dns_name.p, cn_len ) == 0 )
+		  break;
+
+	         if ( cur->general_name.name.dns_name.len > 2 &&
+		      memcmp( cur->general_name.name.dns_name.p, "*.", 2 ) == 0 &&
+		      x509_check_wildcard( cn, &cur->general_name.name.dns_name ) == 0 )
+	         {
+		   break;
+		 }
+	    }
+      }
+#else
         for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )
         {
             if( x509_crt_check_san( &cur->buf, cn, cn_len ) == 0 )
@@ -3036,6 +3224,7 @@ static void x509_crt_verify_name( const mbedtls_x509_crt *crt,
 
         if( cur == NULL )
             *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+#endif
     }
     else
     {
@@ -3271,6 +3460,10 @@ void mbedtls_x509_crt_free( mbedtls_x509_crt *crt )
     mbedtls_x509_crt *cert_prv;
     mbedtls_x509_name *name_cur;
     mbedtls_x509_name *name_prv;
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    mbedtls_x509_general_names *san_cur;
+    mbedtls_x509_general_names *san_prv;
+#endif
     mbedtls_x509_sequence *seq_cur;
     mbedtls_x509_sequence *seq_prv;
 
@@ -3313,6 +3506,38 @@ void mbedtls_x509_crt_free( mbedtls_x509_crt *crt )
             mbedtls_free( seq_prv );
         }
 
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+        if ( cert_cur->subject_alt_names.general_name.name_type == MBEDTLS_X509_GENERALNAME_DIRECTORYNAME )
+        {
+            name_cur = cert_cur->subject_alt_names.general_name.name.directory_name;
+            while ( name_cur != NULL )
+            {
+                name_prv = name_cur;
+                name_cur = name_cur->next;
+                mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
+                mbedtls_free( name_prv );
+            }
+        }
+        san_cur = cert_cur->subject_alt_names.next;
+        while ( san_cur != NULL )
+        {
+            san_prv = san_cur;
+            san_cur = san_cur->next;
+            if ( san_prv->general_name.name_type == MBEDTLS_X509_GENERALNAME_DIRECTORYNAME )
+            {
+                name_cur = san_prv->general_name.name.directory_name;
+                while ( name_cur != NULL )
+                {
+                    name_prv = name_cur;
+                    name_cur = name_cur->next;
+                    mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
+                    mbedtls_free( name_prv );
+                }
+            }
+            mbedtls_platform_zeroize( san_prv, sizeof( mbedtls_x509_general_names ));
+            mbedtls_free( san_prv );
+        }
+#else
         seq_cur = cert_cur->subject_alt_names.next;
         while( seq_cur != NULL )
         {
@@ -3322,6 +3547,7 @@ void mbedtls_x509_crt_free( mbedtls_x509_crt *crt )
                                       sizeof( mbedtls_x509_sequence ) );
             mbedtls_free( seq_prv );
         }
+#endif
 
         seq_cur = cert_cur->certificate_policies.next;
         while( seq_cur != NULL )
diff --git a/library/x509write_crt.c b/library/x509write_crt.c
index 17b3e7966..2fe439095 100644
--- a/library/x509write_crt.c
+++ b/library/x509write_crt.c
@@ -290,6 +290,63 @@ int mbedtls_x509write_crt_set_ns_cert_type( mbedtls_x509write_cert *ctx,
     return( 0 );
 }
 
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+static int x509write_crt_set_subject_alt_name( unsigned char **c, unsigned char *buf,
+                                               const mbedtls_x509_general_name *name )
+{
+    int ret;
+    size_t len = 0;
+
+    switch ( name->name_type )
+    {
+    case MBEDTLS_X509_GENERALNAME_DNSNAME:
+        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_raw_buffer( c, buf, name->name.dns_name.p, name->name.dns_name.len ) );
+        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( c, buf, name->name.dns_name.len ) );
+        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( c, buf, MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ) );
+        break;
+
+    case MBEDTLS_X509_GENERALNAME_DIRECTORYNAME:
+        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_x509_write_names( c, buf, name->name.directory_name ) );
+        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( c, buf, len ) );
+        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( c, buf,
+                                   MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 4 ) );
+        break;
+
+    default:
+        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
+    }
+
+    return( (int)len );
+}
+
+int mbedtls_x509write_crt_set_subject_alt_names( mbedtls_x509write_cert *ctx,
+                                                 const mbedtls_x509_general_names *names )
+{
+    int ret;
+    unsigned char buf[2048];
+    unsigned char *c = buf + sizeof( buf );
+    size_t len = 0;
+    const mbedtls_x509_general_names *cur;
+
+    for ( cur = names; cur != NULL; cur = cur->next )
+    {
+        MBEDTLS_ASN1_CHK_ADD( len, x509write_crt_set_subject_alt_name( &c, buf, &cur->general_name ) );
+    }
+
+    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &c, buf, len ) );
+    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) );
+
+    ret = mbedtls_x509write_crt_set_extension( ctx, MBEDTLS_OID_SUBJECT_ALT_NAME,
+                                               MBEDTLS_OID_SIZE( MBEDTLS_OID_SUBJECT_ALT_NAME ),
+                                               0, c, len );
+
+    if( ret != 0 )
+        return( ret );
+
+    return( 0 );
+}
+#endif /* MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT */
+
 static int x509_write_time( unsigned char **p, unsigned char *start,
                             const char *t, size_t size )
 {
diff --git a/programs/ssl/ssl_client2.c b/programs/ssl/ssl_client2.c
index 57f7d8f67..b58f2af69 100644
--- a/programs/ssl/ssl_client2.c
+++ b/programs/ssl/ssl_client2.c
@@ -102,6 +102,8 @@ int main( void )
 #define DFL_FALLBACK            -1
 #define DFL_EXTENDED_MS         -1
 #define DFL_ETM                 -1
+#define DFL_EKU_CLIENT          ""
+#define DFL_EKU_SERVER          ""
 #define DFL_SERIALIZE           0
 #define DFL_CONTEXT_FILE        ""
 #define DFL_EXTENDED_MS_ENFORCE -1
@@ -322,6 +324,10 @@ int main( void )
 #define USAGE_ECJPAKE ""
 #endif
 
+#define USAGE_EKU \
+    "    eku=%%s-%%s           default: client-server\n"          \
+    "                        options for each: server, client, codesign\n"
+
 #if defined(MBEDTLS_ECP_RESTARTABLE)
 #define USAGE_ECRESTART \
     "    ec_max_ops=%%s       default: library default (restart disabled)\n"
@@ -411,6 +417,7 @@ int main( void )
     USAGE_CURVES                                            \
     USAGE_SIG_ALGS                                          \
     USAGE_DHMLEN                                            \
+    USAGE_EKU                                               \
     "\n"
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
@@ -503,6 +510,10 @@ struct options
     int dgram_packing;          /* allow/forbid datagram packing            */
     int extended_ms;            /* negotiate extended master secret?        */
     int etm;                    /* negotiate encrypt then mac?              */
+    const char *eku_cli;        /* EKU to check for in client cert          */
+    size_t eku_cli_len;         /* length of eku_cli                        */
+    const char *eku_srv;        /* EKU to check for in server cert          */
+    size_t eku_srv_len;         /* length of eku_srv                        */ 
     int context_crt_cb;         /* use context-specific CRT verify callback */
     int eap_tls;                /* derive EAP-TLS keying material?          */
     int nss_keylog;             /* export NSS key log material              */
@@ -870,6 +881,10 @@ int main( int argc, char *argv[] )
     opt.extended_ms         = DFL_EXTENDED_MS;
     opt.etm                 = DFL_ETM;
     opt.dgram_packing       = DFL_DGRAM_PACKING;
+    opt.eku_cli             = DFL_EKU_CLIENT;
+    opt.eku_cli_len         = MBEDTLS_OID_SIZE( DFL_EKU_CLIENT );
+    opt.eku_srv             = DFL_EKU_SERVER;
+    opt.eku_srv_len         = MBEDTLS_OID_SIZE( DFL_EKU_SERVER );    
     opt.serialize           = DFL_SERIALIZE;
     opt.context_file        = DFL_CONTEXT_FILE;
     opt.eap_tls             = DFL_EAP_TLS;
@@ -1304,6 +1319,47 @@ int main( int argc, char *argv[] )
         {
             opt.mki = q;
         }
+        else if ( strcmp(p, "eku") == 0 )
+        {
+            if ( ( p = strchr( q, '-' ) ) == NULL )
+                goto usage;
+            *p++ = '\0';
+            if ( strcmp( q, "server" ) == 0 )
+            {
+                opt.eku_cli = MBEDTLS_OID_SERVER_AUTH;
+                opt.eku_cli_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_SERVER_AUTH);
+            }
+            else if ( strcmp( q, "client" ) == 0 )
+            {
+                opt.eku_cli = MBEDTLS_OID_CLIENT_AUTH;
+                opt.eku_cli_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_CLIENT_AUTH);
+            }
+            else if ( strcmp( q, "codesign" ) == 0 )
+            {
+                opt.eku_cli = MBEDTLS_OID_CODE_SIGNING;
+                opt.eku_cli_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_CODE_SIGNING);
+            }
+            else
+                goto usage;
+
+            if ( strcmp( p, "server" ) == 0 )
+            {
+                opt.eku_srv = MBEDTLS_OID_SERVER_AUTH;
+                opt.eku_srv_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_SERVER_AUTH);
+            }
+            else if ( strcmp( p, "client" ) == 0 )
+            {
+                opt.eku_srv = MBEDTLS_OID_CLIENT_AUTH;
+                opt.eku_srv_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_CLIENT_AUTH);
+            }
+            else if ( strcmp( p, "codesign" ) == 0 )
+            {
+                opt.eku_srv = MBEDTLS_OID_CODE_SIGNING;
+                opt.eku_srv_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_CODE_SIGNING);
+            }
+            else
+                goto usage;
+        }
         else
             goto usage;
     }
@@ -1732,6 +1788,17 @@ int main( int argc, char *argv[] )
         mbedtls_ssl_conf_sig_hashes( &conf, ssl_sig_hashes_for_test );
     }
 
+    if ( opt.eku_cli_len > 0 && opt.eku_srv_len > 0 )
+    {
+        if( ( ret = mbedtls_ssl_conf_ekus( &conf,
+                        opt.eku_cli, opt.eku_cli_len,
+                        opt.eku_srv, opt.eku_srv_len ) ) != 0 )
+        {
+            mbedtls_printf( " failed\n  ! mbedtls_ssl_config_ekus returned -0x%x\n\n", -ret );
+           goto exit;
+        }
+    } 
+
     if( opt.context_crt_cb == 0 )
         mbedtls_ssl_conf_verify( &conf, my_verify, NULL );
 
diff --git a/programs/ssl/ssl_server2.c b/programs/ssl/ssl_server2.c
index 7cbdaf62c..2440c9717 100644
--- a/programs/ssl/ssl_server2.c
+++ b/programs/ssl/ssl_server2.c
@@ -137,6 +137,8 @@ int main( void )
 #define DFL_DGRAM_PACKING        1
 #define DFL_EXTENDED_MS         -1
 #define DFL_ETM                 -1
+#define DFL_EKU_CLIENT          ""
+#define DFL_EKU_SERVER          ""
 #define DFL_SERIALIZE           0
 #define DFL_CONTEXT_FILE        ""
 #define DFL_EXTENDED_MS_ENFORCE -1
@@ -434,6 +436,10 @@ int main( void )
 #define USAGE_SIG_ALGS ""
 #endif
 
+#define USAGE_EKU \
+    "    eku=%%s-%%s           default: client-server\n"          \
+    "                        options for each: server, client, codesign\n"
+
 #if defined(MBEDTLS_SSL_CONTEXT_SERIALIZATION)
 #define USAGE_SERIALIZATION \
     "    serialize=%%d        default: 0 (do not serialize/deserialize)\n"     \
@@ -510,6 +516,7 @@ int main( void )
     USAGE_EMS                                               \
     USAGE_ETM                                               \
     USAGE_CURVES                                            \
+    USAGE_EKU                                               \
     USAGE_SIG_ALGS                                          \
     "\n"
 
@@ -629,6 +636,10 @@ struct options
     int dtls_mtu;               /* UDP Maximum tranport unit for DTLS       */
     int dgram_packing;          /* allow/forbid datagram packing            */
     int badmac_limit;           /* Limit of records with bad MAC            */
+    const char *eku_cli;        /* EKU to check for in client cert          */
+    size_t eku_cli_len;         /* length of eku_cli                        */
+    const char *eku_srv;        /* EKU to check for in server cert          */
+    size_t eku_srv_len;         /* length of eku_srv                        */    
     int eap_tls;                /* derive EAP-TLS keying material?          */
     int nss_keylog;             /* export NSS key log material              */
     const char *nss_keylog_file; /* NSS key log file                        */
@@ -1555,6 +1566,10 @@ int main( int argc, char *argv[] )
     opt.badmac_limit        = DFL_BADMAC_LIMIT;
     opt.extended_ms         = DFL_EXTENDED_MS;
     opt.etm                 = DFL_ETM;
+    opt.eku_cli             = DFL_EKU_CLIENT;
+    opt.eku_cli_len         = MBEDTLS_OID_SIZE( DFL_EKU_CLIENT );
+    opt.eku_srv             = DFL_EKU_SERVER;
+    opt.eku_srv_len         = MBEDTLS_OID_SIZE( DFL_EKU_SERVER );   
     opt.serialize           = DFL_SERIALIZE;
     opt.context_file        = DFL_CONTEXT_FILE;
     opt.eap_tls             = DFL_EAP_TLS;
@@ -2022,6 +2037,47 @@ int main( int argc, char *argv[] )
         {
             opt.support_mki = atoi( q );
         }
+        else if( strcmp( p, "eku" ) == 0 )
+        {
+            if( ( p = strchr( q, '-' ) ) == NULL )
+                goto usage;
+            *p++ = '\0';
+            if( strcmp( q, "server" ) == 0 )
+            {
+                opt.eku_cli = MBEDTLS_OID_SERVER_AUTH;
+                opt.eku_cli_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_SERVER_AUTH );
+            }
+            else if( strcmp( q, "client" ) == 0 )
+            {
+                opt.eku_cli = MBEDTLS_OID_CLIENT_AUTH;
+                opt.eku_cli_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CLIENT_AUTH );
+            }
+            else if( strcmp( q, "codesign" ) == 0 )
+            {
+                opt.eku_cli = MBEDTLS_OID_CODE_SIGNING;
+                opt.eku_cli_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CODE_SIGNING );
+            }
+            else
+                goto usage;
+
+            if( strcmp( p, "server" ) == 0 )
+            {
+                opt.eku_srv = MBEDTLS_OID_SERVER_AUTH;
+                opt.eku_srv_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_SERVER_AUTH );
+            }
+            else if( strcmp( p, "client" ) == 0 )
+            {
+                opt.eku_srv = MBEDTLS_OID_CLIENT_AUTH;
+                opt.eku_srv_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CLIENT_AUTH );
+            }
+            else if( strcmp( p, "codesign" ) == 0 )
+            {
+                opt.eku_srv = MBEDTLS_OID_CODE_SIGNING;
+                opt.eku_srv_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CODE_SIGNING );
+            }
+            else
+                goto usage;
+        }
         else
             goto usage;
     }
@@ -2566,6 +2622,17 @@ int main( int argc, char *argv[] )
         goto exit;
     }
 
+    if ( opt.eku_cli_len > 0 && opt.eku_srv_len > 0 )
+    {
+        if( ( ret = mbedtls_ssl_conf_ekus( &conf,
+                        opt.eku_cli, opt.eku_cli_len,
+                        opt.eku_srv, opt.eku_srv_len ) ) != 0 )
+        {
+            mbedtls_printf( " failed\n  ! mbedtls_ssl_config_ekus returned -0x%x\n\n", -ret );
+            goto exit;
+        }
+    }
+
 #if defined(MBEDTLS_X509_CRT_PARSE_C)
     /* The default algorithms profile disables SHA-1, but our tests still
        rely on it heavily. Hence we allow it here. A real-world server
diff --git a/programs/ssl/ssl_test_lib.h b/programs/ssl/ssl_test_lib.h
index 6b9e7b8da..9c7815366 100644
--- a/programs/ssl/ssl_test_lib.h
+++ b/programs/ssl/ssl_test_lib.h
@@ -80,6 +80,7 @@
 #include "mbedtls/debug.h"
 #include "mbedtls/timing.h"
 #include "mbedtls/base64.h"
+#include "mbedtls/oid.h"
 #include "test/certs.h"
 
 #if defined(MBEDTLS_USE_PSA_CRYPTO) || defined(MBEDTLS_TEST_USE_PSA_CRYPTO_RNG)
diff --git a/programs/x509/cert_write.c b/programs/x509/cert_write.c
index 763f8684f..5e0f59073 100644
--- a/programs/x509/cert_write.c
+++ b/programs/x509/cert_write.c
@@ -65,6 +65,16 @@ int main( void )
 #define USAGE_CSR ""
 #endif /* MBEDTLS_X509_CSR_PARSE_C */
 
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+#define USAGE_SUBJ_ALT_NAME \
+    "    subj_alt_name=%%s    default: (empty)\n"       \
+    "                        Comma-separated-list of values:\n"      \
+    "                          dns_name=%%s\n"          \
+    "                          directory_name=(OU=%%s;CN=%%s;...)\n"
+#else
+#define USAGE_SUBJ_ALT_NAME ""
+#endif /* MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT */
+
 #define DFL_ISSUER_CRT          ""
 #define DFL_REQUEST_FILE        ""
 #define DFL_SUBJECT_KEY         "subject.key"
@@ -147,6 +157,7 @@ int main( void )
     "                            ssl_ca\n"                \
     "                            email_ca\n"              \
     "                            object_signing_ca\n"     \
+    USAGE_SUBJ_ALT_NAME                                   \
     "\n"
 
 
@@ -177,6 +188,9 @@ struct options
     mbedtls_md_type_t md;       /* Hash used for signing                */
     unsigned char key_usage;    /* key usage flags                      */
     unsigned char ns_cert_type; /* NS cert type                         */
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    mbedtls_x509_general_names subj_alt_names; /* Subject alternative names  */
+#endif
 } opt;
 
 int write_certificate( mbedtls_x509write_cert *crt, const char *output_file,
@@ -209,6 +223,58 @@ int write_certificate( mbedtls_x509write_cert *crt, const char *output_file,
     return( 0 );
 }
 
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+static int add_subj_alt_name( mbedtls_x509_general_names **cur, const mbedtls_x509_general_name *add )
+{
+    mbedtls_x509_general_names *new_cur = *cur;
+
+    if ( new_cur->general_name.name_type != 0 )
+    {
+        if (new_cur->next != NULL)
+            return( -1 );
+
+        new_cur->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_general_names ) );
+
+        if (new_cur->next == NULL)
+            return( -1 );
+
+        new_cur = new_cur->next;
+    }
+
+    memcpy( &new_cur->general_name, add, sizeof( mbedtls_x509_general_name ) );
+
+    *cur = new_cur;
+
+    return( 0 );
+}
+
+static void subj_alt_names_free( mbedtls_x509_general_names *names )
+{
+    mbedtls_x509_general_names *cur = names;
+    mbedtls_x509_general_names *prv;
+
+    while ( cur != NULL )
+    {
+        prv = cur;
+        cur = cur->next;
+
+        if ( prv->general_name.name_type == MBEDTLS_X509_GENERALNAME_DIRECTORYNAME )
+        {
+            mbedtls_asn1_free_named_data_list( &prv->general_name.directory_name );
+        }
+
+        /*
+         * The first node is part of the opt struct and not heap allocated, so don't free it.
+         * Every other loop, free the node.
+         */
+        if ( prv != names )
+        {
+            mbedtls_free( prv );
+        }
+    }
+}
+#endif
+
 int main( int argc, char *argv[] )
 {
     int ret = 1;
@@ -230,6 +296,10 @@ int main( int argc, char *argv[] )
     mbedtls_entropy_context entropy;
     mbedtls_ctr_drbg_context ctr_drbg;
     const char *pers = "crt example app";
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    mbedtls_x509_general_names *name_cur = &opt.subj_alt_names;
+    mbedtls_x509_general_name name_tmp;
+#endif
 
     /*
      * Set to sane values
@@ -275,6 +345,9 @@ int main( int argc, char *argv[] )
     opt.subject_identifier   = DFL_SUBJ_IDENT;
     opt.authority_identifier = DFL_AUTH_IDENT;
     opt.basic_constraints    = DFL_CONSTRAINTS;
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    memset( &opt.subj_alt_names, 0, sizeof( opt.subj_alt_names ) );
+#endif
 
     for( i = 1; i < argc; i++ )
     {
@@ -456,6 +529,86 @@ int main( int argc, char *argv[] )
                 q = r;
             }
         }
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+        else if( strcmp( p, "subj_alt_name" ) == 0 )
+        {
+            while( q != NULL )
+            {
+                char *s;
+
+                if( ( r = strchr( q, ',' ) ) != NULL )
+                    *r++ = '\0';
+
+                if( ( s = strchr( q, '=' ) ) == NULL )
+                    goto usage;
+
+                *s++ = '\0';
+
+                if( strcmp( q, "dns_name" ) == 0 )
+                {
+                    name_tmp.name_type = MBEDTLS_X509_GENERALNAME_DNSNAME;
+                    name_tmp.dns_name.len = strlen( s );
+                    name_tmp.dns_name.p = (unsigned char *)s;
+                    /* tag field doesn't need to be set for writing. */
+                }
+                else if( strcmp( q, "directory_name" ) == 0 )
+                {
+                    char *rp, *tmp;
+
+                    if ( *s != '(' )
+                        goto usage;
+
+                    if ( ( rp = strchr( s + 1, ')' ) ) == NULL )
+                        goto usage;
+
+                    /*
+                     * Replace semicolons in the parenthesized list with commas and temporarily
+                     * terminate with null so we can use mbedtls_x509_string_to_names, call it,
+                     * and then change them back so the commas don't interfere with later parsing.
+                     */
+
+                    for ( tmp = s + 1; tmp < rp; tmp++ )
+                    {
+                        if ( *tmp == ';' )
+                        {
+                            *tmp = ',';
+                        }
+                    }
+
+                    *rp = '\0';
+
+                    name_tmp.name_type = MBEDTLS_X509_GENERALNAME_DIRECTORYNAME;
+                    name_tmp.directory_name = NULL;
+                    ret = mbedtls_x509_string_to_names( &name_tmp.directory_name, s + 1 );
+
+                    if ( ret < 0 )
+                    {
+                        mbedtls_strerror( ret, buf, 1024 );
+                        mbedtls_printf( " failed\n  ! mbedtls_x509_string_to_names returned %d - %s\n", ret, buf );
+                        goto exit;
+                    }
+
+                    for ( tmp = s + 1; tmp < rp; tmp++ )
+                    {
+                        if ( *tmp == ',' )
+                        {
+                            *tmp = ';';
+                        }
+                    }
+
+                    *rp = ')';
+
+                }
+                else
+                    goto usage;
+
+                if ( add_subj_alt_name( &name_cur, &name_tmp ) != 0 )
+                    goto exit;
+
+                q = r;
+            }
+        }
+#endif /* MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT */
         else
             goto usage;
     }
@@ -762,6 +915,24 @@ int main( int argc, char *argv[] )
         mbedtls_printf( " ok\n" );
     }
 
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    if ( opt.subj_alt_names.general_name.name_type )
+    {
+        mbedtls_printf( "  . Adding the Subject Alternative Name extension ..." );
+        fflush( stdout );
+
+        ret = mbedtls_x509write_crt_set_subject_alt_names( &crt, &opt.subj_alt_names );
+        if ( ret != 0 )
+        {
+            mbedtls_strerror( ret, buf, 1024 );
+            mbedtls_printf( " failed\n  !  mbedtls_x509write_crt_set_subject_alt_names returned -0x%02x - %s\n\n", -ret, buf );
+            goto exit;
+        }
+
+        mbedtls_printf( " ok\n" );
+    }
+#endif
+
     /*
      * 1.2. Writing the certificate
      */
@@ -786,6 +957,11 @@ exit:
     mbedtls_x509_csr_free( &csr );
 #endif /* MBEDTLS_X509_CSR_PARSE_C */
     mbedtls_x509_crt_free( &issuer_crt );
+
+#if defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
+    subj_alt_names_free( &opt.subj_alt_names );
+#endif
+
     mbedtls_x509write_crt_free( &crt );
     mbedtls_pk_free( &loaded_subject_key );
     mbedtls_pk_free( &loaded_issuer_key );
